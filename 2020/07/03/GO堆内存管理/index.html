<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="综述讨论什么本文主要讨论go语言的运行时环境，对虚拟内存的管理与优化。go的runtime内存管理，封装了OS层的细节，为GMP运行时环境提供了内存管理功能。并提供一系列辅助方法协助runtime完成内存的垃圾回收、用量统计等功能。 内存管理与垃圾回收密不可分，在本文中讨论的内容虽然主要是内存管理，但也会对GC和gmp的一些内容简要介绍。 这里假设读者已经具有基本的操作系统常识、对虚拟内存的基本认">
<meta property="og:type" content="article">
<meta property="og:title" content="GO堆内存管理">
<meta property="og:url" content="http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="Sugar">
<meta property="og:description" content="综述讨论什么本文主要讨论go语言的运行时环境，对虚拟内存的管理与优化。go的runtime内存管理，封装了OS层的细节，为GMP运行时环境提供了内存管理功能。并提供一系列辅助方法协助runtime完成内存的垃圾回收、用量统计等功能。 内存管理与垃圾回收密不可分，在本文中讨论的内容虽然主要是内存管理，但也会对GC和gmp的一些内容简要介绍。 这里假设读者已经具有基本的操作系统常识、对虚拟内存的基本认">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/bournex/go_source_analysis/master/images/goheap-arenahint.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/bournex/go_source_analysis/master/images/goheap-heapArena.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/bournex/go_source_analysis/master/images/goheap-spanstatus.jpg">
<meta property="article:published_time" content="2020-07-03T05:25:30.000Z">
<meta property="article:modified_time" content="2020-07-03T05:27:12.570Z">
<meta property="article:author" content="Bourne Liu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/bournex/go_source_analysis/master/images/goheap-arenahint.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>GO堆内存管理</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/bournex?tab=repositories" target="_blank" rel="noopener">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/07/27/channel%E5%8E%9F%E7%90%86/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/07/02/hello-world/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&text=GO堆内存管理" target="_blank" rel="noopener"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=GO堆内存管理" target="_blank" rel="noopener"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&is_video=false&description=GO堆内存管理" target="_blank" rel="noopener"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=GO堆内存管理&body=Check out this article: http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=GO堆内存管理" target="_blank" rel="noopener"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=GO堆内存管理" target="_blank" rel="noopener"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=GO堆内存管理" target="_blank" rel="noopener"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=GO堆内存管理" target="_blank" rel="noopener"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&name=GO堆内存管理&description=" target="_blank" rel="noopener"><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#综述"><span class="toc-number">1.</span> <span class="toc-text">综述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#讨论什么"><span class="toc-number">1.1.</span> <span class="toc-text">讨论什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runtime代码范围"><span class="toc-number">1.2.</span> <span class="toc-text">runtime代码范围</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#预备知识"><span class="toc-number">2.</span> <span class="toc-text">预备知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#常用全局变量"><span class="toc-number">2.1.</span> <span class="toc-text">常用全局变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计思想"><span class="toc-number">2.2.</span> <span class="toc-text">设计思想</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#系统级内存管理"><span class="toc-number">3.</span> <span class="toc-text">系统级内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原始堆内存的初始化"><span class="toc-number">3.1.</span> <span class="toc-text">原始堆内存的初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arenaHints"><span class="toc-number">3.2.</span> <span class="toc-text">arenaHints</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arena"><span class="toc-number">3.3.</span> <span class="toc-text">Arena</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arena"><span class="toc-number">3.3.1.</span> <span class="toc-text">arena</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#heapArena"><span class="toc-number">3.3.2.</span> <span class="toc-text">heapArena</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#heapArena索引计算"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">heapArena索引计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关联mspan与heapArena"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">关联mspan与heapArena</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何判定指针是否在堆上"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">如何判定指针是否在堆上</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存分配核心方法"><span class="toc-number">3.4.</span> <span class="toc-text">内存分配核心方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#系统级内存分配方法"><span class="toc-number">3.4.1.</span> <span class="toc-text">系统级内存分配方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小内存非堆分配方法"><span class="toc-number">3.4.2.</span> <span class="toc-text">小内存非堆分配方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#persistentAlloc"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">persistentAlloc</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆原始内存分配器"><span class="toc-number">3.4.3.</span> <span class="toc-text">堆原始内存分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定长对象分配器"><span class="toc-number">3.4.4.</span> <span class="toc-text">定长对象分配器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary"><span class="toc-number">3.5.</span> <span class="toc-text">summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#堆内存管理"><span class="toc-number">4.</span> <span class="toc-text">堆内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mspan"><span class="toc-number">4.1.</span> <span class="toc-text">mspan</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆缓存管理"><span class="toc-number">4.2.</span> <span class="toc-text">堆缓存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#小对象缓存"><span class="toc-number">4.2.1.</span> <span class="toc-text">小对象缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#大对象缓存"><span class="toc-number">4.2.2.</span> <span class="toc-text">大对象缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆增长"><span class="toc-number">4.3.</span> <span class="toc-text">堆增长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆内存分配与释放"><span class="toc-number">4.4.</span> <span class="toc-text">堆内存分配与释放</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#allocSpanLocked"><span class="toc-number">4.4.1.</span> <span class="toc-text">allocSpanLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#freeSpanLocked"><span class="toc-number">4.4.2.</span> <span class="toc-text">freeSpanLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#alloc-alloc-m"><span class="toc-number">4.4.3.</span> <span class="toc-text">alloc&#x2F;alloc_m</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小对象mspan"><span class="toc-number">4.5.</span> <span class="toc-text">小对象mspan</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mspan空闲块"><span class="toc-number">4.5.1.</span> <span class="toc-text">mspan空闲块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mspan空闲块的查找"><span class="toc-number">4.5.2.</span> <span class="toc-text">mspan空闲块的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#nextFreeFast"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">nextFreeFast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nextFree"><span class="toc-number">4.5.2.2.</span> <span class="toc-text">nextFree</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小对象内存划分"><span class="toc-number">4.6.</span> <span class="toc-text">小对象内存划分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeClass"><span class="toc-number">4.6.1.</span> <span class="toc-text">sizeClass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spanClass"><span class="toc-number">4.6.2.</span> <span class="toc-text">spanClass</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小对象内存分配器"><span class="toc-number">4.7.</span> <span class="toc-text">小对象内存分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mcentral"><span class="toc-number">4.7.1.</span> <span class="toc-text">mcentral</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cacheSpan"><span class="toc-number">4.7.1.1.</span> <span class="toc-text">cacheSpan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uncacheSpan"><span class="toc-number">4.7.1.2.</span> <span class="toc-text">uncacheSpan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#freeSpan"><span class="toc-number">4.7.1.3.</span> <span class="toc-text">freeSpan</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mcache"><span class="toc-number">4.7.2.</span> <span class="toc-text">mcache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mcache分配小对象空间"><span class="toc-number">4.7.2.1.</span> <span class="toc-text">mcache分配小对象空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#大对象内存分配器"><span class="toc-number">4.8.</span> <span class="toc-text">大对象内存分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#largeAlloc"><span class="toc-number">4.8.1.</span> <span class="toc-text">largeAlloc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#手动管理内存的分配与释放"><span class="toc-number">4.9.</span> <span class="toc-text">手动管理内存的分配与释放</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#allocManual"><span class="toc-number">4.9.1.</span> <span class="toc-text">allocManual</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#freeManual"><span class="toc-number">4.9.2.</span> <span class="toc-text">freeManual</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mspan的状态变迁"><span class="toc-number">4.10.</span> <span class="toc-text">mspan的状态变迁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary-1"><span class="toc-number">4.11.</span> <span class="toc-text">summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#应用级内存管理"><span class="toc-number">5.</span> <span class="toc-text">应用级内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newobject"><span class="toc-number">5.0.1.</span> <span class="toc-text">newobject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newarray"><span class="toc-number">5.0.2.</span> <span class="toc-text">newarray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mallocgc"><span class="toc-number">5.0.3.</span> <span class="toc-text">mallocgc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary-2"><span class="toc-number">5.1.</span> <span class="toc-text">summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存分配流程"><span class="toc-number">6.</span> <span class="toc-text">内存分配流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存分配流程串联"><span class="toc-number">6.1.</span> <span class="toc-text">内存分配流程串联</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#堆内存的回收"><span class="toc-number">7.</span> <span class="toc-text">堆内存的回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#scavenge"><span class="toc-number">7.1.</span> <span class="toc-text">scavenge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scavengelist"><span class="toc-number">7.2.</span> <span class="toc-text">scavengelist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scavengetreap"><span class="toc-number">7.3.</span> <span class="toc-text">scavengetreap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Finalizer-amp-SetFinalizer"><span class="toc-number">7.4.</span> <span class="toc-text">Finalizer&amp;SetFinalizer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回收时机"><span class="toc-number">7.5.</span> <span class="toc-text">回收时机</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他"><span class="toc-number">8.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存用量统计"><span class="toc-number">8.1.</span> <span class="toc-text">内存用量统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#德布鲁因序列"><span class="toc-number">8.2.</span> <span class="toc-text">德布鲁因序列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#引用"><span class="toc-number">9.</span> <span class="toc-text">引用</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        GO堆内存管理
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Sugar</span>
      </span>
      
    <div class="postdate">
        <time datetime="2020-07-03T05:25:30.000Z" itemprop="datePublished">2020-07-03</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><h2 id="讨论什么"><a href="#讨论什么" class="headerlink" title="讨论什么"></a>讨论什么</h2><p>本文主要讨论go语言的运行时环境，对虚拟内存的管理与优化。go的runtime内存管理，封装了OS层的细节，为GMP运行时环境提供了内存管理功能。并提供一系列辅助方法协助runtime完成内存的垃圾回收、用量统计等功能。</p>
<p>内存管理与垃圾回收密不可分，在本文中讨论的内容虽然主要是内存管理，但也会对GC和gmp的一些内容简要介绍。</p>
<p>这里假设读者已经具有基本的操作系统常识、对虚拟内存的基本认知、系统内存管理api以及一般的内存管理常识等知识。</p>
<p>第一部分讨论了go对系统虚拟内存的封装、对虚拟内存空间的规划等基本方法。</p>
<p>第二部分讨论了go在内存缓存、内存分配、分片、合并、多线程支持等方面的实现原理。</p>
<p>第三部分讨论了内存管理的应用。即runtime提供给go使用者的相关接口和逻辑。</p>
<p>第四部分讨论了go内存的回收。</p>
<h2 id="runtime代码范围"><a href="#runtime代码范围" class="headerlink" title="runtime代码范围"></a>runtime代码范围</h2><p>本文讨论的runtime代码范围如下：</p>
<p>mmap.go - 系统api封装，操作系统相关</p>
<p>malloc.go - 系统内存管理封装，new关键字主要逻辑实现</p>
<p>mheap.go - 堆内存管理</p>
<p>mcentral.go - 小内存中央分配器</p>
<p>mcache.go - 小内存线程局部分配器</p>
<p>sizeclasses.go - size类定义</p>
<p>mgclarge.go - 树堆数据结构实现及大内存回收</p>
<p>mfixalloc.go - 定长非堆通用分配器</p>
<p>mbitmap.go - mspan对象位图操作</p>
<p>共约4K行代码</p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="常用全局变量"><a href="#常用全局变量" class="headerlink" title="常用全局变量"></a>常用全局变量</h2><p>为避免出现理解上的偏差，本文默认讨论的场景主要为amd64架构下的64位linux系统环境。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">	<span class="comment">// go中定义的内存页大小为8KB</span></span><br><span class="line">	_PageShift = <span class="number">13</span></span><br><span class="line">	_PageSize = <span class="number">1</span> &lt;&lt; _PageShift</span><br><span class="line">	_PageMask = _PageSize - <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 固定长度分配器单次申请空间大小为16KB</span></span><br><span class="line">	_FixAllocChunk = <span class="number">16</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// tiny内存块大小</span></span><br><span class="line">	_TinySize      = <span class="number">16</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// go中堆的最大寻址范围。64位系统中为48（bit）</span></span><br><span class="line">	heapAddrBits = (_64bit*(<span class="number">1</span>-sys.GoarchWasm))*<span class="number">48</span> + (<span class="number">1</span>-_64bit+sys.GoarchWasm)*(<span class="number">32</span>-(sys.GoarchMips+sys.GoarchMipsle))</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 最大可用用户虚拟内存空间大小，即1&lt;&lt;48=256TB，实际达不到这么大。</span></span><br><span class="line">	maxAlloc = (<span class="number">1</span> &lt;&lt; heapAddrBits) - (<span class="number">1</span>-_64bit)*<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// heap arena大小的对数值，64位系统为26</span></span><br><span class="line">	logHeapArenaBytes = (<span class="number">6</span>+<span class="number">20</span>)*(_64bit*(<span class="number">1</span>-sys.GoosWindows)) + (<span class="number">2</span>+<span class="number">20</span>)*(_64bit*sys.GoosWindows) + (<span class="number">2</span>+<span class="number">20</span>)*(<span class="number">1</span>-_64bit)</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// heap arena大小</span></span><br><span class="line">	heapArenaBytes = <span class="number">1</span> &lt;&lt; logHeapArenaBytes</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// heap arena的bitmap数组大小</span></span><br><span class="line">	heapArenaBitmapBytes = heapArenaBytes / (sys.PtrSize * <span class="number">8</span> / <span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 一个heapArena包含的虚拟内存页数量</span></span><br><span class="line">	pagesPerArena = heapArenaBytes / pageSize</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// heapArena指针二维数组中第一维的大小，64位系统为0，所以二维数组退化为一维</span></span><br><span class="line">	arenaL1Bits = <span class="number">6</span> * (_64bit * sys.GoosWindows)</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// heapArena指针二维数组中的第二维大小，64位系统中为26</span></span><br><span class="line">	arenaL2Bits = heapAddrBits - logHeapArenaBytes - arenaL1Bits</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 系统物理内存页最小值4KB</span></span><br><span class="line">	minPhysPageSize = <span class="number">4096</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>go的内存管理参考了tcmalloc，tcmalloc是google开源的一款内存管理工具。对比glibc中的ptmalloc2，tcmalloc对多线程更加友好。增加了分配器的跨线程使用，解决了ptmalloc中线程局部分配器不均匀的问题，并对小内存的分配进行了优化。</p>
<p>go中弱化了线程的概念，提出了goroutine的并发模型，runtime中实现了系统线程对goroutine的调度和资源管理，但其goroutine还是依赖线程来实现的并发，所以线程局部分配器，还是在系统线程的层面管理。具体来说，p对象和工作中的m对象都会持有线程局部的分配器。</p>
<h1 id="系统级内存管理"><a href="#系统级内存管理" class="headerlink" title="系统级内存管理"></a>系统级内存管理</h1><h2 id="原始堆内存的初始化"><a href="#原始堆内存的初始化" class="headerlink" title="原始堆内存的初始化"></a>原始堆内存的初始化</h2><p>操作系统提供的虚拟内存空间，是由寻找空间决定的，在amd64位系统上，有48个bit用于寻址，所以我们的可用地址空间，在1&lt;&lt;48个，这里没有占满64bit，因为48bit已经提供了256TB的虚拟地址寻址空间。这几乎已经足够大部分的系统应用了。</p>
<p>go在mallocinit中初始化了128个arenahint对象，从0xC000000000开始循环128次，令每个arenahint.addr指向1TB空间的起始地址。作为堆内存的寻址指引。所有在应用程序中通过new关键字创建的对象地址，最终都指向大于0xC000000000的地址。</p>
<p>虽然arenahint链表表达了有128TB空间之大，但堆内存的地址不止如此，当128TB空间耗尽后，arenahint链表还会继续扩张。</p>
<p>选择将堆地址放在0xC000000000的位置，注释阐明了原因。一方面方便调试时识别堆内存空间。另一方面，在用大端法表达地址时，C0不是有效的UTF-8字符，可以一定程度上规避指针类型被错误解释成UTF8字符。</p>
<p>我们且称这部分128TB的内存为堆原始内存。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the heap.</span></span><br><span class="line">	mheap_.init()</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	_g_.m.mcache = allocmcache()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &amp;&amp; GOARCH != <span class="string">"wasm"</span> &#123;</span><br><span class="line">    <span class="comment">// 64位系统下，获得128个1TB内存块的起始地址</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0x7f</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">			<span class="keyword">var</span> p <span class="keyword">uintptr</span></span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> GOARCH == <span class="string">"arm64"</span> &amp;&amp; GOOS == <span class="string">"darwin"</span>:</span><br><span class="line">				p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0013</span>&lt;&lt;<span class="number">28</span>)</span><br><span class="line">			<span class="keyword">case</span> GOARCH == <span class="string">"arm64"</span>:</span><br><span class="line">				p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x0040</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				p = <span class="keyword">uintptr</span>(i)&lt;&lt;<span class="number">40</span> | uintptrMask&amp;(<span class="number">0x00c0</span>&lt;&lt;<span class="number">32</span>)</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 起始地址被保存在arenaHint链表中</span></span><br><span class="line">			hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())</span><br><span class="line">			hint.addr = p</span><br><span class="line">			hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 32位系统的初始化过程</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="arenaHints"><a href="#arenaHints" class="headerlink" title="arenaHints"></a>arenaHints</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> arenaHint <span class="keyword">struct</span> &#123;</span><br><span class="line">	addr <span class="keyword">uintptr</span>		<span class="comment">// 记录了在当前arenaHint的区间内，已经分配到的内存地址位置，addr只会单调增长或降低。</span></span><br><span class="line">	down <span class="keyword">bool</span>				<span class="comment">// 默认为false，从低地址向高地址增长。</span></span><br><span class="line">	next *arenaHint	<span class="comment">// 下一个arena区间的arenaHint对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arenahint指向最原始的虚拟内存空间，runtime.sysAlloc函数分配空间时以heapArenaBytes(64MB)为单位从arenaHint链表头对象开始分配空间。当第一个arenaHint的1TB空间被用完后，将开始使用下一个arenaHint的空间。</p>
<p><img src="https://raw.githubusercontent.com/bournex/go_source_analysis/master/images/goheap-arenahint.jpg" alt="arenaHints"></p>
<h2 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h2><h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>arena是tcmalloc中没有的概念，go中基于垃圾回收的考虑，需要对内存进行更加精细化的管理。所以增加了arena的概念。arena中文翻译是竞技场，没什么卵用。</p>
<p>go中将arena定义为一段连续的64MB空间。堆原始内存的分配，提供的接口为系统页数量，实际分配时会对齐到64MB的arena来分配，即所有arena的起始地址，都是从虚拟地址空间0x0开始的64MB整数倍位置。</p>
<h3 id="heapArena"><a href="#heapArena" class="headerlink" title="heapArena"></a>heapArena</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> heapArena <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// bitmap是一个byte数组，它用于表达在64MB的arena空间中，是否需要被GC扫描。</span></span><br><span class="line">	<span class="comment">// 其中每2个bit表达arena中的一个PtrSize（64bit）空间。所以bitmap数组长度为2MB。</span></span><br><span class="line">	<span class="comment">// 2bit的地位表示对应的arena中start+N*PtrSize位置开始的8字节上是否有指针。</span></span><br><span class="line">	<span class="comment">// 2bit中，高位表示是否需要被GC关心，低位表示当前bitmap表达的bytes是否包含指针。</span></span><br><span class="line">	bitmap [heapArenaBitmapBytes]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// arena被按照系统页大小划分，在amd64Go中page为8KB，所以pagesPerArena</span></span><br><span class="line">	<span class="comment">// 也是8KB。即arena空间被分为0 - (8192-1)个mspan指针。其中被分配的page</span></span><br><span class="line">	<span class="comment">// ，对应在spans中的mspan	为当前持有该空间的mspan指针。如果一个区域没有</span></span><br><span class="line">	<span class="comment">// 被使用，则这个区域的首尾page在spans中的对象指向该mspan。如果arena中</span></span><br><span class="line">	<span class="comment">// 一段page序列从来未分配过，则该区间的page在spans中的mspan指针值为nil。</span></span><br><span class="line">	<span class="comment">// setSpan方法完成了对spans的初始化。写需要加锁，读不需要。</span></span><br><span class="line">	spans [pagesPerArena]*mspan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>heapArena标识一个arena。整个虚拟内存地址空间，被按照arena管理起来，每64MB对应一个heapArena对象。heapArena对象通过persistentalloc申请，申请的对象被挂到mheap.arenas二级索引下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// arenas是一个二维数组，通过这个二维数组，构成了对整个虚拟内存寻址空间的</span></span><br><span class="line">	<span class="comment">// 描述。在64位系统中，arenaL1Bits为0，arenaL2Bits为22（4MB）。</span></span><br><span class="line">  <span class="comment">// 堆中用了4MB的空间，描述了整个虚拟内存的使用情况和包含指针情况。</span></span><br><span class="line">	arenas [<span class="number">1</span> &lt;&lt; arenaL1Bits]*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在mheap类中的arenas成员使用一个二维指针表达了整个虚拟内存空间。并提供了一些方法来操作这个空间。比如根据指针值，计算出其对应的heapArena对象。</p>
<p><img src="https://raw.githubusercontent.com/bournex/go_source_analysis/master/images/goheap-heapArena.jpg" alt=""></p>
<h4 id="heapArena索引计算"><a href="#heapArena索引计算" class="headerlink" title="heapArena索引计算"></a>heapArena索引计算</h4><p>arenas中，arenaL1Bits、arenaL2Bits分别表达了第一维和第二维的bit shift，在64位系统上，arenaL1Bits为0，arenaL2Bits为22。所以最多会有4MB个heapArena对象。由于每个heapArena对象都表达了64MB的虚拟内存空间，所以4MB * 64MB = 1 &lt;&lt; 48，arenas就覆盖了整个虚拟内存空间。</p>
<p>对于一个给定的地址p，共有48个bit位为有效地址bit，其前arenaL1Bits位bit作为第一维索引，这里为0。所以前arenaL2Bits位bit作为第二维索引，这里为22。go使用arenaIndex来计算p对应的heapArena对象在arenas二维数组中的位置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arenaIndex</span><span class="params">(p <span class="keyword">uintptr</span>)</span> <span class="title">arenaIdx</span></span> &#123;</span><br><span class="line">  <span class="comment">// p加上arenaBaseOffset，除以arena的大小，得到一个index值。</span></span><br><span class="line">	<span class="comment">// arenaBaseOffset用于将</span></span><br><span class="line">	<span class="keyword">return</span> arenaIdx((p + arenaBaseOffset) / heapArenaBytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> arenaIdx <span class="keyword">uint</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得前arenaL1Bits位作为L1索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i arenaIdx)</span> <span class="title">l1</span><span class="params">()</span> <span class="title">uint</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> arenaL1Bits == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">uint</span>(i) &gt;&gt; arenaL1Shift</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得从l1 index开始的arenaL2Bits位，作为L2索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i arenaIdx)</span> <span class="title">l2</span><span class="params">()</span> <span class="title">uint</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> arenaL1Bits == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">uint</span>(i)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">uint</span>(i) &amp; (<span class="number">1</span>&lt;&lt;arenaL2Bits - <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们提到过，系统上寻址空间为48位。而指针变量为64位。</p>
<p>amd在设计64位系统的虚拟内存空间时，对地址定义做了如下限制：即要求指针值的48-63位，必须要与第47位一致，否则访存时会触发异常。</p>
<p>根据这一规则，go中将index的计算进行了特殊处理，即向地址追加一个0x8000 0000 0000的arena基址再计算index，这会产生如下效果：</p>
<ul>
<li>对于0x0000 0000 0000 - 0x7FFF FFFF FFFF的地址，追加arena基址后，获得的arenaIndex位于arenas二维数组的后半部分。</li>
<li>对于0x8000 0000 0000 - 0xFFFF FFFF FFFF的地址，追加arena基址后，触发了地址值的溢出，由于这部分地址的高位为0xFFFF，因此计算后获得的arenaIndex位于arenas二位数组的前半部分。</li>
</ul>
<h4 id="关联mspan与heapArena"><a href="#关联mspan与heapArena" class="headerlink" title="关联mspan与heapArena"></a>关联mspan与heapArena</h4><p>关联主要通过setSpan/setSpans方法实现。实现方式也很简单，对于传入的地址计算其arenaIndex，找出该地址所属的heapArena对象，将通过除以系统页大小获得在整个虚拟空间上页的索引，将mspan指针设置到span成员的指定slot上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">setSpan</span><span class="params">(base <span class="keyword">uintptr</span>, s *mspan)</span></span> &#123;</span><br><span class="line">	ai := arenaIndex(base)</span><br><span class="line">	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆npage数量的pages的所有者在heapArean.spans上标记为s</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">setSpans</span><span class="params">(base, npage <span class="keyword">uintptr</span>, s *mspan)</span></span> &#123;</span><br><span class="line">	p := base / pageSize</span><br><span class="line">	ai := arenaIndex(base)</span><br><span class="line">	ha := h.arenas[ai.l1()][ai.l2()]</span><br><span class="line">	<span class="keyword">for</span> n := <span class="keyword">uintptr</span>(<span class="number">0</span>); n &lt; npage; n++ &#123;</span><br><span class="line">		i := (p + n) % pagesPerArena</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			ai = arenaIndex(base + n*pageSize)</span><br><span class="line">			ha = h.arenas[ai.l1()][ai.l2()]</span><br><span class="line">		&#125;</span><br><span class="line">		ha.spans[i] = s</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setSpan和setSpans建立起了heapArena到mspan的映射关系，这为后面实现通过任意指针地址查找对应的mspan提供了支持。</p>
<h4 id="如何判定指针是否在堆上"><a href="#如何判定指针是否在堆上" class="headerlink" title="如何判定指针是否在堆上"></a>如何判定指针是否在堆上</h4><p>go堆中的内存，所有已分配的空间是由称作mspan类型的对象来持有并管理的，在原始虚拟内存中，mallocinit初始化时限定了堆内存的绝对分配范围，mheap通过heapArena对所有的堆内存进行了划分，而heapArena中的spans成员又保存了64MB的空间下每个物理页归属的mspan对象。所以只要是有效的堆内存地址，都可以唯一地映射到一个heapArena对象上。也可以直接映射到一个mspan对象上。</p>
<p>go提供了几个方法来查找指针对应的heapArena对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spanOf</span><span class="params">(p <span class="keyword">uintptr</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">	ri := arenaIndex(p)</span><br><span class="line">	<span class="keyword">if</span> arenaL1Bits == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ri.l2() &gt;= <span class="keyword">uint</span>(<span class="built_in">len</span>(mheap_.arenas[<span class="number">0</span>])) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ri.l1() &gt;= <span class="keyword">uint</span>(<span class="built_in">len</span>(mheap_.arenas)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	l2 := mheap_.arenas[ri.l1()]</span><br><span class="line">	<span class="keyword">if</span> arenaL1Bits != <span class="number">0</span> &amp;&amp; l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	ha := l2[ri.l2()]</span><br><span class="line">	<span class="keyword">if</span> ha == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ha.spans[(p/pageSize)%pagesPerArena]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果p不在有效堆内存范围内，则返回nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spanOfHeap</span><span class="params">(p <span class="keyword">uintptr</span>)</span> *<span class="title">mspan</span></span></span><br></pre></td></tr></table></figure>

<p>如果一段arena虚拟内存地址没有在go中被分配过，则其地址对应的heapArena指针为空。</p>
<h2 id="内存分配核心方法"><a href="#内存分配核心方法" class="headerlink" title="内存分配核心方法"></a>内存分配核心方法</h2><p>malloc.go中提供了几个主要的内存分配方法。这些方法实现了对操作系统虚拟内存空间的分配。通常来说这些方法不提供内存的释放。因为在malloc.go基础上，runtime实现了大部分内存的复用。</p>
<h3 id="系统级内存分配方法"><a href="#系统级内存分配方法" class="headerlink" title="系统级内存分配方法"></a>系统级内存分配方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从v开始映射长度为n的内存，底层依赖mmap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysMap</span><span class="params">(v unsafe.Pointer, n <span class="keyword">uintptr</span>, sysStat *<span class="keyword">uint64</span>)</span></span></span><br><span class="line"><span class="comment">// 从v开始保留长度为n的内存，底层依赖mmap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysReserve</span><span class="params">(v unsafe.Pointer, n <span class="keyword">uintptr</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span></span><br><span class="line"><span class="comment">// 释放从v开始的长度为n的内存，底层依赖munmap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysFree</span><span class="params">(v unsafe.Pointer, n <span class="keyword">uintptr</span>, sysStat *<span class="keyword">uint64</span>)</span></span></span><br><span class="line"><span class="comment">// 申请长度为n的内存，返回系统指定的虚拟内存空间起始地址，底层依赖mmap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysAlloc</span><span class="params">(n <span class="keyword">uintptr</span>, sysStat *<span class="keyword">uint64</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span></span><br><span class="line"><span class="comment">// 向系统归还从v开始的指定长度n的内存，底层依赖madvise</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysUnused</span><span class="params">(v unsafe.Pointer, n <span class="keyword">uintptr</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>go中对系统级内存分配方法进行了二次封装。代码中给出了依赖的底层系统方法。</p>
<h3 id="小内存非堆分配方法"><a href="#小内存非堆分配方法" class="headerlink" title="小内存非堆分配方法"></a>小内存非堆分配方法</h3><p>全局小内存块申请方法。该方法传入一个需求大小和对齐大小、返回一个指针，指向申请的空间起始地址。其中align必须是2的指数倍且小于pageSize。</p>
<p>persistentalloc在系统栈上调用了persistentalloc1，实际分配动作由persistentalloc1完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">persistentalloc1</span><span class="params">(size, align <span class="keyword">uintptr</span>, sysStat *<span class="keyword">uint64</span>)</span> *<span class="title">notInHeap</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		chunk    = <span class="number">256</span> &lt;&lt; <span class="number">10</span>	<span class="comment">// 256KB</span></span><br><span class="line">		maxBlock = <span class="number">64</span> &lt;&lt; <span class="number">10</span> 	<span class="comment">// 64KB</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...将align对齐到2的指数倍</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 大于64KB直接向操作系统申请</span></span><br><span class="line">	<span class="keyword">if</span> size &gt;= maxBlock &#123;</span><br><span class="line">		<span class="keyword">return</span> (*notInHeap)(sysAlloc(size, sysStat))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前m对象下的persistentAlloc对象，如果当前没有运行在gmp环境下，则使用</span></span><br><span class="line">	<span class="comment">// 全局的persistentAlloc对象分配内存，需要加锁。</span></span><br><span class="line">	mp := acquirem()</span><br><span class="line">	<span class="keyword">var</span> persistent *persistentAlloc</span><br><span class="line">	<span class="keyword">if</span> mp != <span class="literal">nil</span> &amp;&amp; mp.p != <span class="number">0</span> &#123;</span><br><span class="line">		persistent = &amp;mp.p.ptr().palloc</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		lock(&amp;globalAlloc.mutex)</span><br><span class="line">		persistent = &amp;globalAlloc.persistentAlloc</span><br><span class="line">	&#125;</span><br><span class="line">	persistent.off = round(persistent.off, align)</span><br><span class="line">	<span class="keyword">if</span> persistent.off+size &gt; chunk || persistent.base == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// chunk无法满足需求大小或chunk不存在时，则申请新的chunk</span></span><br><span class="line">		persistent.base = (*notInHeap)(sysAlloc(chunk, &amp;memstats.other_sys))</span><br><span class="line">		<span class="keyword">if</span> persistent.base == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> persistent == &amp;globalAlloc.persistentAlloc &#123;</span><br><span class="line">				unlock(&amp;globalAlloc.mutex)</span><br><span class="line">			&#125;</span><br><span class="line">			throw(<span class="string">"runtime: cannot allocate memory"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		persistent.off = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在预分配的chunk上规划需要的内存，并找到首地址返回，增加base的偏移</span></span><br><span class="line">	p := persistent.base.add(persistent.off)</span><br><span class="line">	persistent.off += size</span><br><span class="line">	releasem(mp)</span><br><span class="line">	<span class="keyword">if</span> persistent == &amp;globalAlloc.persistentAlloc &#123;</span><br><span class="line">		unlock(&amp;globalAlloc.mutex)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码申请了一个满足size需求的空间。align会被对齐到2的指数倍。</p>
<ul>
<li><p>如果size大于64kb，则直接调用系统mmap分配空间。</p>
</li>
<li><p>如果size小于64kb，找到当前m对象下的persistentAlloc对象，在其偏移位上分配一个size的空间。并返回。</p>
</li>
<li><p>如果persistentAlloc对象已经不足以分配该size的内存。则直接分配一个新的256KB的chunk，令m的persistentAlloc.base指向该chunk。</p>
</li>
</ul>
<p>go运行时有一种叫m的对象，用于表达一个系统工作线程及其状态。为了加速小内存的线程内快速分配，避免因向堆内存申请空间导致的锁竞争，所以为每个m对象指定了一个persistentAlloc，用于加速线程局部小内存分配速度。同时，runtime中也创建了一个全局带锁的persistentAlloc对象，用于go运行时小内存分配。</p>
<p>persistentalloc调用了persistentalloc1方法。</p>
<p>persistentalloc1方法返回的是一个notInHeap指针，表明了该方法申请的内存不是在go划分的原始堆内存以内申请的。实际上由于调用的是sysAlloc方法，所以chunk分配在哪儿、实际内存在什么位置由操作系统决定。</p>
<p>persistentalloc1分配的内存不提供释放方法。这是由于该方法申请的空间在上层大多提供对象池实现，所以总体上来说其已分配的内存是收敛的。</p>
<h4 id="persistentAlloc"><a href="#persistentAlloc" class="headerlink" title="persistentAlloc"></a>persistentAlloc</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> persistentAlloc <span class="keyword">struct</span> &#123;</span><br><span class="line">	base *notInHeap	<span class="comment">// 当前chunk的首地址</span></span><br><span class="line">	off  <span class="keyword">uintptr</span>			<span class="comment">// 当前chunk上已经分配空间的偏移量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="堆原始内存分配器"><a href="#堆原始内存分配器" class="headerlink" title="堆原始内存分配器"></a>堆原始内存分配器</h3><p>sysAlloc只有在堆增长（mheap.grow）的时候才会被调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">sysAlloc</span><span class="params">(n <span class="keyword">uintptr</span>)</span> <span class="params">(v unsafe.Pointer, size <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 将需求空间大小对齐到arena大小，即64MB</span></span><br><span class="line">	n = round(n, heapArenaBytes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Try to grow the heap at a hint address.</span></span><br><span class="line">	<span class="keyword">for</span> h.arenaHints != <span class="literal">nil</span> &#123;</span><br><span class="line">		hint := h.arenaHints</span><br><span class="line">		p := hint.addr</span><br><span class="line">		<span class="keyword">if</span> hint.down &#123;</span><br><span class="line">			p -= n</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> p+n &lt; p &#123;</span><br><span class="line">			v = <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> arenaIndex(p+n<span class="number">-1</span>) &gt;= <span class="number">1</span>&lt;&lt;arenaBits &#123;</span><br><span class="line">			v = <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 预留当前空闲的地址空间</span></span><br><span class="line">			v = sysReserve(unsafe.Pointer(p), n)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> p == <span class="keyword">uintptr</span>(v) &#123;</span><br><span class="line">			<span class="comment">// 更新areanHints当前addr的指针位置，用于下次分配。</span></span><br><span class="line">			<span class="keyword">if</span> !hint.down &#123;</span><br><span class="line">				p += n</span><br><span class="line">			&#125;</span><br><span class="line">			hint.addr = p</span><br><span class="line">			size = n</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果当前arenaHints下没有找到合适的空间，则查找下一个</span></span><br><span class="line">		<span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">			sysFree(v, n, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		h.arenaHints = hint.next</span><br><span class="line">		h.arenaHintAlloc.free(unsafe.Pointer(hint))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 一般应用程序不会执行到这里，因为这表明256TB的原始堆空间都已经分配殆尽</span></span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 向系统申请任意起始地址的空间，对齐到heapArenaBytes。</span></span><br><span class="line">		v, size = sysReserveAligned(<span class="literal">nil</span>, n, heapArenaBytes)</span><br><span class="line">		<span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建新的areanHint并添加到列表</span></span><br><span class="line">		hint := (*arenaHint)(h.arenaHintAlloc.alloc())</span><br><span class="line">		hint.addr, hint.down = <span class="keyword">uintptr</span>(v), <span class="literal">true</span></span><br><span class="line">		hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">		hint = (*arenaHint)(h.arenaHintAlloc.alloc())</span><br><span class="line">		hint.addr = <span class="keyword">uintptr</span>(v) + size</span><br><span class="line">		hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将前面预留的空间重新映射回来。</span></span><br><span class="line">	sysMap(v, size, &amp;memstats.heap_sys)</span><br><span class="line"></span><br><span class="line">mapped:</span><br><span class="line">	<span class="comment">// Create arena metadata.</span></span><br><span class="line">	<span class="keyword">for</span> ri := arenaIndex(<span class="keyword">uintptr</span>(v)); ri &lt;= arenaIndex(<span class="keyword">uintptr</span>(v)+size<span class="number">-1</span>); ri++ &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="comment">// 更新mheap.arenas对象，增加对当前申请空间的描述heapArena对象。</span></span><br><span class="line">		atomic.StorepNoWB(unsafe.Pointer(&amp;l2[ri.l2()]), unsafe.Pointer(r))</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sysAlloc通过hints，从原始规划的堆空间申请一段符合需求量n的内存，返回其空间起始地址和实际mmap的内存大小。所有基于堆内存的分配，最终都指向了sysAlloc方法，这也是操作hints表达的堆内存的唯一途径。</p>
<h3 id="定长对象分配器"><a href="#定长对象分配器" class="headerlink" title="定长对象分配器"></a>定长对象分配器</h3><p>对于一些运行时常驻内存的，且有缓存的固定长度对象，比如mspan，go中设计了固定长度对象分配器。由于这类内存需求长度固定易于管理，且需求空间较小，所以没有使用堆原始内存分配器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> fixalloc <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 固定对象长度</span></span><br><span class="line">	size   <span class="keyword">uintptr</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">	first  <span class="function"><span class="keyword">func</span><span class="params">(arg, p unsafe.Pointer)</span></span></span><br><span class="line">	arg    unsafe.Pointer</span><br><span class="line">  <span class="comment">// 空闲对象链表指针</span></span><br><span class="line">	list   *mlink</span><br><span class="line">  <span class="comment">// 当前用于分配新对象的chunk块偏移地址</span></span><br><span class="line">	chunk  <span class="keyword">uintptr</span></span><br><span class="line">  <span class="comment">// 当前chunk块中剩余未分配的字节数量</span></span><br><span class="line">	nchunk <span class="keyword">uint32</span></span><br><span class="line">  <span class="comment">// 当前chunk块中使用中的字节数量，inuse + nchunk = _FixAllocChunk</span></span><br><span class="line">	inuse  <span class="keyword">uintptr</span></span><br><span class="line">	stat   *<span class="keyword">uint64</span></span><br><span class="line">  <span class="comment">// 是否需要将新申请的对象空间置为0</span></span><br><span class="line">	zero   <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mlink <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 空闲对象链表指针，空闲的对象的内存是随机值，它的地址空间会被临时视为一个mlink对象</span></span><br><span class="line">  <span class="comment">// 用于构建空闲对象内存链表。当一块空闲对象被分配时，mlink空间被覆盖。</span></span><br><span class="line">	next *mlink</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定长对象分配器不属于基本的内存分配器，但在堆中经常会用到。其内存的分配和释放实现也很简单</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fixalloc)</span> <span class="title">alloc</span><span class="params">()</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> f.size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"runtime: use of FixAlloc_Alloc before FixAlloc_Init\n"</span>)</span><br><span class="line">		throw(<span class="string">"runtime: internal error"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> f.list != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 优先从空闲对象链表中查找</span></span><br><span class="line">		v := unsafe.Pointer(f.list)</span><br><span class="line">		f.list = f.list.next</span><br><span class="line">		f.inuse += f.size</span><br><span class="line">		<span class="keyword">if</span> f.zero &#123;</span><br><span class="line">			memclrNoHeapPointers(v, f.size)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> v</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 向系统申请_FixAllocChunk = 16KB的chunk块，用于对象分配。所以fixalloc只能</span></span><br><span class="line">  <span class="comment">// 分配小于16KB的对象内存。</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span>(f.nchunk) &lt; f.size &#123;</span><br><span class="line">		f.chunk = <span class="keyword">uintptr</span>(persistentalloc(_FixAllocChunk, <span class="number">0</span>, f.stat))</span><br><span class="line">		f.nchunk = _FixAllocChunk</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v := unsafe.Pointer(f.chunk)</span><br><span class="line">	<span class="keyword">if</span> f.first != <span class="literal">nil</span> &#123;</span><br><span class="line">		f.first(f.arg, v)</span><br><span class="line">	&#125;</span><br><span class="line">	f.chunk = f.chunk + f.size</span><br><span class="line">	f.nchunk -= <span class="keyword">uint32</span>(f.size)</span><br><span class="line">	f.inuse += f.size</span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fixalloc)</span> <span class="title">free</span><span class="params">(p unsafe.Pointer)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 释放并将归还的内存解释为mlink，加入到空闲链表中</span></span><br><span class="line">	f.inuse -= f.size</span><br><span class="line">	v := (*mlink)(p)</span><br><span class="line">	v.next = f.list</span><br><span class="line">	f.list = v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面的代码说明了堆对象中的6中定长分配器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// mspan对象分配器</span></span><br><span class="line">	spanalloc             fixalloc</span><br><span class="line">	<span class="comment">// mcache对象分配器</span></span><br><span class="line">	cachealloc            fixalloc</span><br><span class="line">	<span class="comment">// treapNode树堆节点对象分配器</span></span><br><span class="line">	treapalloc            fixalloc</span><br><span class="line">	<span class="comment">// TODO</span></span><br><span class="line">	  fixalloc</span><br><span class="line">	<span class="comment">// TODO</span></span><br><span class="line">	specialprofilealloc   fixalloc</span><br><span class="line">	<span class="comment">// arenaHint对象分配器</span></span><br><span class="line">	arenaHintAlloc        fixalloc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>以上是对go中系统虚拟内存的规划与分配介绍，这里共介绍了四类虚拟内存分配方法。</p>
<p>系统级内存分配 - 主要是通过mmap族系统方法实现虚拟内存的映射。</p>
<p>小内存非堆分配 - 通过直接向操作系统映射内存的方式，获得非堆管理的内存空间。通过此方法分配的空间，大部分用于函数签名上带有//go:notinheap前缀，它们不会被GC关心。</p>
<p>堆原始内存分配 - 原始堆内存的主要，也是唯一的分配方法。</p>
<p>定长对象分配 - 用于分配非堆的定长对象。</p>
<p>这些内存分配器，是go runtime的基本内存分配方法，它们主要对操作系统的内存操作api进行了封装，为后面的堆内存管理提供原始空间的内存分配方法。</p>
<h1 id="堆内存管理"><a href="#堆内存管理" class="headerlink" title="堆内存管理"></a>堆内存管理</h1><p>堆作为运行时的动态内存分配器，主要需要解决以下问题：</p>
<ol>
<li>如何快速有效的响应内存分配的需求。</li>
<li>如果有效避免内存碎片的产生。</li>
</ol>
<p>go runtime中通过以下途径，来解决上述问题</p>
<ol>
<li>建立堆缓存减少系统调用。</li>
<li>将缓存的内存块按照大小分开管理。</li>
<li>将不需要被GC扫描的内存分开管理。</li>
<li>将空闲的连续内存块合并。</li>
<li>为每个线程建立独立的内存分配器。</li>
<li>使用专用分配器为常用定长对象分配空间。</li>
</ol>
<p>堆中的内存以物理页（page）为单位进行管理。当前go中定义的物理页大小为8KB</p>
<p>堆以128个物理页（1MB）为界。</p>
<p>占用物理页小于128个的，按小对象处理</p>
<p>占用物理页大于等于128个的，按大对象处理</p>
<h2 id="mspan"><a href="#mspan" class="headerlink" title="mspan"></a>mspan</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 用于构成链表时的链表指针</span></span><br><span class="line">	next *mspan</span><br><span class="line">	prev *mspan</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mspan指向的内存空间起始地址，可以通过mspan.base()方法获得</span></span><br><span class="line">	startAddr <span class="keyword">uintptr</span></span><br><span class="line">  <span class="comment">// 当前mspan下的内存空间包含多少个系统页</span></span><br><span class="line">	npages    <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于栈内存管理TODO</span></span><br><span class="line">	manualFreeList gclinkptr</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前mspan空闲可分配的对象索引。如果freeindex==nelems，则mspan已无可用空间</span></span><br><span class="line">	freeindex <span class="keyword">uintptr</span></span><br><span class="line">	<span class="comment">// 当前mspan能分配的elemsize大小对象的最大数量</span></span><br><span class="line">	nelems <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 作为当前allocBits的一个滑动窗口，用于快速计算当前的可用空间。</span></span><br><span class="line">  <span class="comment">// allocCache的64个bit位，表达了64个slot。初始化为^0。</span></span><br><span class="line">  <span class="comment">// 应用中，go通过德布鲁因算法快速获得当前allocCache中bit为1的最低位，作为</span></span><br><span class="line">  <span class="comment">// freeindex的补充，通过freeindex+lowbit(allocCache)获得当前空闲的slot。</span></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// 同时，由于allocCache只能表达64个slot，所以还需要配合allocBits来使用。</span></span><br><span class="line">	allocCache <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前mspan中slot使用情况汇总。在mspan初始化时按照elemsize申请空间。其每个</span></span><br><span class="line">  <span class="comment">// bit位表达一个slot，如果bit位为1，表明这个slot已经被分配，否则slot空闲。</span></span><br><span class="line">	allocBits  *gcBits</span><br><span class="line">	gcmarkBits *gcBits</span><br><span class="line"></span><br><span class="line">  <span class="comment">// GC相关，暂不讨论</span></span><br><span class="line">	divMul      <span class="keyword">uint16</span></span><br><span class="line">	baseMask    <span class="keyword">uint16</span></span><br><span class="line">  <span class="comment">// 当前mspan上已经分配的对象数量</span></span><br><span class="line">	allocCount  <span class="keyword">uint16</span></span><br><span class="line">  <span class="comment">// 当前mspan的spanClass</span></span><br><span class="line">	spanclass   spanClass</span><br><span class="line">  <span class="comment">// 表明当前mspan是否被mcache缓存</span></span><br><span class="line">	incache     <span class="keyword">bool</span></span><br><span class="line">  <span class="comment">// mspan状态，共有四种状态</span></span><br><span class="line">  <span class="comment">// _MSpanDead、_MSpanInUse、_MSpanManual、_MSpanFree</span></span><br><span class="line">	state       mSpanState</span><br><span class="line">  <span class="comment">// 从当前mspan分配对象时，是否需要将对象的内存空间初始化为0</span></span><br><span class="line">	needzero    <span class="keyword">uint8</span></span><br><span class="line">	divShift    <span class="keyword">uint8</span></span><br><span class="line">	divShift2   <span class="keyword">uint8</span></span><br><span class="line">  <span class="comment">// mspan能分配的对象大小</span></span><br><span class="line">	elemsize    <span class="keyword">uintptr</span></span><br><span class="line">  <span class="comment">// 当前mspan最近一次使用的nano时间戳，用于判定是否需要向系统归还内存</span></span><br><span class="line">	unusedsince <span class="keyword">int64</span></span><br><span class="line">	npreleased  <span class="keyword">uintptr</span>    <span class="comment">// number of pages released to the os</span></span><br><span class="line">  <span class="comment">// 当前mspan指向空间的结束为止+1字节</span></span><br><span class="line">	limit       <span class="keyword">uintptr</span></span><br><span class="line">	speciallock mutex      <span class="comment">// guards specials list</span></span><br><span class="line">	specials    *special   <span class="comment">// linked list of special records sorted by offset.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆中无论是空闲还是使用中的内存，都使用mspan对象来表达。mspan中持有系统页整数倍的内存空间。通过state状态标记来标识当前mspan是被使用中还是空闲中。</p>
<p>mspan中持有的空间，可用来分配一个或多个相同类型的对象空间，elemsize表明了对象类型占用的空间大小。nelems表明了当前mspan下可以分配对象的最大数量。</p>
<p>mspan在mheap、mcentral、mcache中都有缓存。</p>
<p>区别在于，在mheap中缓存的mspan对象是以page为单位的，npages表明了mheap中的mspan对象所持有的系统页数量。mheap分配空间时，根据需求的page数量，分配合适的mspan给使用者。mheap不会分配半个mspan给使用者。</p>
<p>而在mcentral、mcache中的mspan，是以spanclass来划分的，spanclass可以理解为一个限定的对象大小。一个mspan被分配到mcentral或mcache后，它的spanclass是固定的，意味着在这个mspan上，只能分配大小固定的对象。详见spanclass。</p>
<p>在堆中，mspan会通过一个包含头尾指针的mSpanList和prev、next指针串联成为一个双向链表。</p>
<p>mSpanList结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mSpanList <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *mspan <span class="comment">// first span in list, or nil if none</span></span><br><span class="line">	last  *mspan <span class="comment">// last span in list, or nil if none</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="堆缓存管理"><a href="#堆缓存管理" class="headerlink" title="堆缓存管理"></a>堆缓存管理</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 用于锁住allspans对象</span></span><br><span class="line">	lock      mutex</span><br><span class="line">  <span class="comment">// 小于等于128个pageSize的空闲mspan链表数组，按照page数量不同而区分保存</span></span><br><span class="line">	free      [_MaxMHeapList]mSpanList</span><br><span class="line">  <span class="comment">// 大于128个pageSize的空闲mspan树堆</span></span><br><span class="line">	freelarge mTreap</span><br><span class="line">  <span class="comment">// 使用中的小于等于128个pageSize的mspan链表数组，按照page数量不同区分保存</span></span><br><span class="line">	busy      [_MaxMHeapList]mSpanList</span><br><span class="line">  <span class="comment">// 使用中的大于128个pageSize的空闲mspan链表，由于总量不会太大，仅使用一个链表保存</span></span><br><span class="line">	busylarge mSpanList</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mheap中使用4个数据结构表达了当前已经缓存的原始堆内存。</p>
<p>// 用于分配tiny和small对象空间的mspan，通过free、busy链表数组来记录</p>
<p>用于分配large对象空间的mspan，通过freelarge树堆、busylarge链表来记录</p>
<h3 id="小对象缓存"><a href="#小对象缓存" class="headerlink" title="小对象缓存"></a>小对象缓存</h3><p>free和busy是一个mSpanList链表数组，数组大小为128，用于分别对应持有1-128个系统页pages空间的mspan对象链表头。free保存了当前处于空闲状态的mspan，而busy保存了当前使用中的mspan。</p>
<h3 id="大对象缓存"><a href="#大对象缓存" class="headerlink" title="大对象缓存"></a>大对象缓存</h3><p>mheap中建立了一个树堆（<a href="https://en.wikipedia.org/wiki/Treap" target="_blank" rel="noopener">Treap</a>），用于保存空闲的大内存mspan对象。在树堆中每个节点都包含一个mspan指针、一个当前mspan占用的npages数量和一个uint32的优先级priority。其中，page数量作为首要排序key，spanKey作为次要排序key。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mTreap <span class="keyword">struct</span> &#123;</span><br><span class="line">	treap *treapNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> treapNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	right     *treapNode <span class="comment">// all treapNodes &gt; this treap node</span></span><br><span class="line">	left      *treapNode <span class="comment">// all treapNodes &lt; this treap node</span></span><br><span class="line">	parent    *treapNode <span class="comment">// direct parent of this node, nil if root</span></span><br><span class="line">	npagesKey <span class="keyword">uintptr</span>    <span class="comment">// number of pages in spanKey, used as primary sort key</span></span><br><span class="line">	spanKey   *mspan     <span class="comment">// span of size npagesKey, used as secondary sort key</span></span><br><span class="line">	priority  <span class="keyword">uint32</span>     <span class="comment">// random number used by treap algorithm to keep tree probabilistically balanced</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Treap中节点的组织需要遵循以下两点原则：</p>
<ul>
<li>左子树下的mspan占用的pages数量小于父节点，右子树下的mspan占用pages数量大于父节点。</li>
<li>父节点的priority值是整棵子树中最小的。</li>
</ul>
<p>priority值在树节点被插入时由当前m对象的fastrand随机种子生成随机数写入。</p>
<p>树堆的旋转，树堆在插入和删除节点时，会通过左右旋转来确保Treap始终满足其原则。</p>
<h2 id="堆增长"><a href="#堆增长" class="headerlink" title="堆增长"></a>堆增长</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">grow</span><span class="params">(npage <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 调用sysAlloc分配ask大小的空间，实际返回的size对齐到64MB</span></span><br><span class="line">	ask := npage &lt;&lt; _PageShift</span><br><span class="line">	v, size := h.sysAlloc(ask)</span><br><span class="line">	<span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里创建了一个状态为_MSpanInUse状态的mspan，目的是在freeSpanLocked中可以</span></span><br><span class="line">	<span class="comment">// 实现连续mspan的合并</span></span><br><span class="line">	s := (*mspan)(h.spanalloc.alloc())</span><br><span class="line">	s.init(<span class="keyword">uintptr</span>(v), size/pageSize)</span><br><span class="line">	h.setSpans(s.base(), s.npages, s)</span><br><span class="line">	atomic.Store(&amp;s.sweepgen, h.sweepgen)</span><br><span class="line">	s.state = _MSpanInUse</span><br><span class="line">	h.pagesInUse += <span class="keyword">uint64</span>(s.npages)</span><br><span class="line">	h.freeSpanLocked(s, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆增长函数调用了此前讨论的系统原始内存分配方法mheap.sysAlloc来分配堆内存。将其状态设置为_MSpanInUse，并调用freeSpanLocked将未使用到的空间放到空闲内存池中。</p>
<p>堆的增长会在sysAlloc中对齐到64MB，所以一次申请至少为64MB空间。触发grow的内存分配操作，除返回满足申请的部分外，其余的空间通过freeSpanLocked被mheap缓存。而下次内存申请时将不再grow，而是优先通过分割缓存中的内存来完成分配。除非因缓存不足而再次触发grow。</p>
<h2 id="堆内存分配与释放"><a href="#堆内存分配与释放" class="headerlink" title="堆内存分配与释放"></a>堆内存分配与释放</h2><p>堆内存的分配释放主要通过allocSpanLocked和freeSpanLocked完成。</p>
<ul>
<li>allocSpanLocked优先从已分配堆内存中进行分配，如果没有合适的堆内存块（mspan），则触发堆增长，并再次申请。</li>
<li>freeSpanLocked将内存块归还到已分配堆内存队列中。一个额外动作是，通过检查当前mspan空间的和其连续空间的前后mspan是否均处于_MSpanFree状态，来决定是否要合并这些mspan。</li>
</ul>
<p>注意这两个方法的命名。Locked表示对这两个方法的调用需要使用mheap.lock加锁，因为其内部操作了mheap的缓存队列或mTreap。</p>
<h3 id="allocSpanLocked"><a href="#allocSpanLocked" class="headerlink" title="allocSpanLocked"></a>allocSpanLocked</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">allocSpanLocked</span><span class="params">(npage <span class="keyword">uintptr</span>, stat *<span class="keyword">uint64</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> list *mSpanList</span><br><span class="line">	<span class="keyword">var</span> s *mspan</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果需求page数量小于128，则优先从mheap.free中获取满足npage数量的mspan</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">int</span>(npage); i &lt; <span class="built_in">len</span>(h.free); i++ &#123;</span><br><span class="line">		list = &amp;h.free[i]</span><br><span class="line">		<span class="keyword">if</span> !list.isEmpty() &#123;</span><br><span class="line">			s = list.first</span><br><span class="line">			list.remove(s)</span><br><span class="line">			<span class="keyword">goto</span> HaveSpan</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果npage大于128，则从mheap.freelarge树堆中分配满足npage数量的mspan</span></span><br><span class="line">	s = h.allocLarge(npage)</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// mheap.freelarge树堆中没有满足条件可用的mspan，则扩张堆空间。</span></span><br><span class="line">		<span class="keyword">if</span> !h.grow(npage) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 再次尝试从堆中申请</span></span><br><span class="line">		s = h.allocLarge(npage)</span><br><span class="line">		<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">HaveSpan:</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.npages &gt; npage &#123;</span><br><span class="line">		<span class="comment">// 从mtreap中获得mspan为最小的满足npage需求的mspan，其实际空间可能大于需求量</span></span><br><span class="line">		<span class="comment">// 如果实际分配的空间大于需求的空间，则使用多余出来的空间构造出一个新的mspan</span></span><br><span class="line">		<span class="comment">// 将新的mspan归还给堆缓存</span></span><br><span class="line">		t := (*mspan)(h.spanalloc.alloc())</span><br><span class="line">		t.init(s.base()+npage&lt;&lt;_PageShift, s.npages-npage)</span><br><span class="line">		s.npages = npage</span><br><span class="line">		h.setSpan(t.base()<span class="number">-1</span>, s)</span><br><span class="line">		h.setSpan(t.base(), t)</span><br><span class="line">		h.setSpan(t.base()+t.npages*pageSize<span class="number">-1</span>, t)</span><br><span class="line">		t.needzero = s.needzero</span><br><span class="line">		s.state = _MSpanManual	<span class="comment">// s是最终要返回的mspan对象，由于其与t是连续的，为了避免free t时发生合并，暂时将s状态置为非_MSpanFree</span></span><br><span class="line">		t.state = _MSpanManual</span><br><span class="line">		h.freeSpanLocked(t, <span class="literal">false</span>, <span class="literal">false</span>, s.unusedsince)</span><br><span class="line">		s.state = _MSpanFree</span><br><span class="line">	&#125;</span><br><span class="line">	s.unusedsince = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新heapArena</span></span><br><span class="line">	h.setSpans(s.base(), npage, s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>allocSpanLocked仅会返回满足需求页数量的内存空间，如果查找到堆中的mspan拥有的系统页数量超过需求量，多余的系统页将被额外新创建的mspan持有，并写回堆缓存中。</p>
<p>allocSpanLocked主要完成空闲mspan从free、freelarge的脱链，返回的mspan处于_MSpanFree状态。</p>
<p>查找mheap.free时时间复杂度最大为O（N）</p>
<h3 id="freeSpanLocked"><a href="#freeSpanLocked" class="headerlink" title="freeSpanLocked"></a>freeSpanLocked</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">freeSpanLocked</span><span class="params">(s *mspan, acctinuse, acctidle <span class="keyword">bool</span>, unusedsince <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将mspan从使用中列表脱链，修改状态为空闲状态</span></span><br><span class="line">	s.state = _MSpanFree</span><br><span class="line">	<span class="keyword">if</span> s.inList() &#123;</span><br><span class="line">		h.busyList(s.npages).remove(s)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果与s连续内存的低地址方向也是一个已分配的空闲的mspan，则合并s和before</span></span><br><span class="line">	<span class="comment">// 两个mspan</span></span><br><span class="line">	<span class="keyword">if</span> before := spanOf(s.base() - <span class="number">1</span>); before != <span class="literal">nil</span> &amp;&amp; before.state == _MSpanFree &#123;</span><br><span class="line">		s.startAddr = before.startAddr</span><br><span class="line">		s.npages += before.npages</span><br><span class="line">		s.npreleased = before.npreleased</span><br><span class="line">		s.needzero |= before.needzero</span><br><span class="line">		h.setSpan(before.base(), s)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从空闲列表中移除before mspan</span></span><br><span class="line">		<span class="keyword">if</span> h.isLargeSpan(before.npages) &#123;</span><br><span class="line">			h.freelarge.removeSpan(before)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			h.freeList(before.npages).remove(before)</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 释放before mspan对象，归还到spanalloc固定对象分配器中</span></span><br><span class="line">		before.state = _MSpanDead</span><br><span class="line">		h.spanalloc.free(unsafe.Pointer(before))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 与before一样</span></span><br><span class="line">	<span class="keyword">if</span> after := spanOf(s.base() + s.npages*pageSize); after != <span class="literal">nil</span> &amp;&amp; after.state == _MSpanFree &#123;</span><br><span class="line">		s.npages += after.npages</span><br><span class="line">		s.npreleased += after.npreleased</span><br><span class="line">		s.needzero |= after.needzero</span><br><span class="line">		h.setSpan(s.base()+s.npages*pageSize<span class="number">-1</span>, s)</span><br><span class="line">		<span class="keyword">if</span> h.isLargeSpan(after.npages) &#123;</span><br><span class="line">			h.freelarge.removeSpan(after)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			h.freeList(after.npages).remove(after)</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 释放after mspan对象，归还到spanalloc固定对象分配器中，固定对象分配器</span></span><br><span class="line">		<span class="comment">// 要求传入的mspan状态必须为_MSpanDead</span></span><br><span class="line">		after.state = _MSpanDead</span><br><span class="line">		h.spanalloc.free(unsafe.Pointer(after))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将前后合并后的s放到空闲mspan列表中。</span></span><br><span class="line">	<span class="keyword">if</span> h.isLargeSpan(s.npages) &#123;</span><br><span class="line">    <span class="comment">// 如果是大于1MB的mspan，则插入到树堆中</span></span><br><span class="line">		h.freelarge.insert(s)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果是小于1MB的mspan，则插入到指定page数量的mspan链表中</span></span><br><span class="line">		h.freeList(s.npages).insert(s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在busy列表中查找使用中的mspan，时间复杂度为常数级。</p>
<h3 id="alloc-alloc-m"><a href="#alloc-alloc-m" class="headerlink" title="alloc/alloc_m"></a>alloc/alloc_m</h3><p>alloc通过调用alloc_m方法实现mspan的分配，并对分配空间进行了必要的清零工作。</p>
<p>实际内存分配的过程在alloc_m中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alloc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc</span><span class="params">(npage <span class="keyword">uintptr</span>, spanclass spanClass, large <span class="keyword">bool</span>, needzero <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// alloc_m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc_m</span><span class="params">(npage <span class="keyword">uintptr</span>, spanclass spanClass, large <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	lock(&amp;h.lock)</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向堆中申请持有npage数量的mspan</span></span><br><span class="line">	s := h.allocSpanLocked(npage, &amp;memstats.heap_inuse)</span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="comment">// 初始化mspan成员</span></span><br><span class="line">		s.state = _MSpanInUse</span><br><span class="line">		s.allocCount = <span class="number">0</span></span><br><span class="line">		s.spanclass = spanclass</span><br><span class="line">		<span class="keyword">if</span> sizeclass := spanclass.sizeclass(); sizeclass == <span class="number">0</span> &#123;</span><br><span class="line">			s.elemsize = s.npages &lt;&lt; _PageShift</span><br><span class="line">			s.divShift = <span class="number">0</span></span><br><span class="line">			s.divMul = <span class="number">0</span></span><br><span class="line">			s.divShift2 = <span class="number">0</span></span><br><span class="line">			s.baseMask = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			s.elemsize = <span class="keyword">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">			m := &amp;class_to_divmagic[sizeclass]</span><br><span class="line">			s.divShift = m.shift</span><br><span class="line">			s.divMul = m.mul</span><br><span class="line">			s.divShift2 = m.shift2</span><br><span class="line">			s.baseMask = m.baseMask</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 记录大内存使用量，并将mspan添加到busy链表</span></span><br><span class="line">		h.pagesInUse += <span class="keyword">uint64</span>(npage)</span><br><span class="line">		<span class="keyword">if</span> large &#123;</span><br><span class="line">			memstats.heap_objects++</span><br><span class="line">			mheap_.largealloc += <span class="keyword">uint64</span>(s.elemsize)</span><br><span class="line">			mheap_.nlargealloc++</span><br><span class="line">			atomic.Xadd64(&amp;memstats.heap_live, <span class="keyword">int64</span>(npage&lt;&lt;_PageShift))</span><br><span class="line">			<span class="comment">// </span></span><br><span class="line">			<span class="keyword">if</span> s.npages &lt; <span class="keyword">uintptr</span>(<span class="built_in">len</span>(h.busy)) &#123;</span><br><span class="line">				h.busy[s.npages].insertBack(s)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				h.busylarge.insertBack(s)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	unlock(&amp;h.lock)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>alloc_m调用allocSpanLocked分配了合适的mspan，完成了mspan的初始化，修改mspan状态为_MSpanInUse，并将mspan追加到mheap的busy链表中。</p>
<p>此外，由于allocSpanLocked/freeSpanLocked是对堆缓存的主要操作方法，所以在调用这两个方法的位置需要加锁，使用的是mheap.lock对象。</p>
<h2 id="小对象mspan"><a href="#小对象mspan" class="headerlink" title="小对象mspan"></a>小对象mspan</h2><h3 id="mspan空闲块"><a href="#mspan空闲块" class="headerlink" title="mspan空闲块"></a>mspan空闲块</h3><p>mspan在mcache或mcentral中被用于小内存分配时，需要将以page为单位从mheap获取的空间按照sizeclass划分。比如包含1个page大小8KB的mspan，当被用作16字节对象分配时，它最多可以分配8192/16=512个对象。mspan的空闲块管理的主要工作就是管理这些对象空间。</p>
<p>空闲块的管理主要通过mspan中的allocBits、allocCache、freeindex和nelems成员实现。</p>
<p>allocBits的类型为gcBits，实际就是byte指针类型。</p>
<p>在mspan被初始化时，通过指定的sizeclass/spanclass，可以计算出其最多可申请的对象数量，还以上面的例子为例：</p>
<p>将mspan的8KB空间视为512个slot。</p>
<p>freeindex在mspan初始化时被置为0。</p>
<p>allocBits作为mspan空间的位图，使用512个bit位（64bytes）表达512个slot的分配状态。如果slot已被分配，则对应位为1，否则为0。</p>
<p>allocCache作为allocBits的滑动窗口，表示当前窗口下的64个slot，配合freeindex和德布鲁因算法，快速查找当前窗口下的空闲slot。不同于allocBits，在allocCache中bit位为1的表示未分配，0表示已分配。</p>
<p>nelems == 512，表示可分配对象的最大数量。</p>
<h3 id="mspan空闲块的查找"><a href="#mspan空闲块的查找" class="headerlink" title="mspan空闲块的查找"></a>mspan空闲块的查找</h3><h4 id="nextFreeFast"><a href="#nextFreeFast" class="headerlink" title="nextFreeFast"></a>nextFreeFast</h4><h4 id="nextFree"><a href="#nextFree" class="headerlink" title="nextFree"></a>nextFree</h4><h2 id="小对象内存划分"><a href="#小对象内存划分" class="headerlink" title="小对象内存划分"></a>小对象内存划分</h2><p>在内存管理中，大块内存比较容易管理，小块内存则是产生内存碎片的祸根。如果任由小块内存在系统中随机分配，最终可能会出现无法申请连续大块内存的情况。</p>
<p>go中为了避免内存碎片，加速小对象的分配效率。对小对象进行了更细粒度的划分，基于缓存的分配器，主要解决的是小于32KB的对象分配问题。</p>
<p>注意区分这里的小对象与mheap中的小对象的区别，堆中的小对象是小于128个page的独立mspan，而基于缓存的分配器，关注的是一个mspan内的空间分配和释放。</p>
<h3 id="sizeClass"><a href="#sizeClass" class="headerlink" title="sizeClass"></a>sizeClass</h3><p>go将小于等于32KB的内存，划分了67个级别，称之为sizeClass。每个级别对应的内存块大小保存在class_to_size数组中。以class_to_size[4]为例，其值为32，即如果我们为一个大小为22字节的对象分配空间时，实际runtime中，会对齐到class_to_size[4]的32字节来申请空间。</p>
<p>这种对小内存的管理方式，为go实现不同大小对象之间无干扰的分配提供了可能。代价则是会损失一部分的空间。在sizeclasses.go的注释中给出了各个sizeClass可能浪费的最大空间。</p>
<p>至于为什么是67，这可能是相对准备32768个不同大小的分配器 和 过分离散的class导致的性能降低之间的一个折中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	_MaxSmallSize   = <span class="number">32768</span></span><br><span class="line">	smallSizeDiv    = <span class="number">8</span></span><br><span class="line">	smallSizeMax    = <span class="number">1024</span></span><br><span class="line">	largeSizeDiv    = <span class="number">128</span></span><br><span class="line">	_NumSizeClasses = <span class="number">67</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 67种sizeclass对应的分配空间大小</span></span><br><span class="line"><span class="keyword">var</span> class_to_size = [_NumSizeClasses]<span class="keyword">uint16</span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 67种sizeclass对应的分配器应持有的系统页数量，被mcentral使用</span></span><br><span class="line"><span class="keyword">var</span> class_to_allocnpages = [_NumSizeClasses]<span class="keyword">uint8</span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 小于1024字节的任意空间大小对应的sizeclass</span></span><br><span class="line"><span class="keyword">var</span> size_to_class8 = [smallSizeMax/smallSizeDiv + <span class="number">1</span>]<span class="keyword">uint8</span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 大于1024、小于32768字节的任意空间大小对应的sizeclass</span></span><br><span class="line"><span class="keyword">var</span> size_to_class128 = [(_MaxSmallSize-smallSizeMax)/largeSizeDiv + <span class="number">1</span>]<span class="keyword">uint8</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>



<h3 id="spanClass"><a href="#spanClass" class="headerlink" title="spanClass"></a>spanClass</h3><p>spanClass是sizeClass的一种特殊表达，它将sizeClass的索引（即0-66）左移一位，低位用于表达noscan标记。如果最低位为1，表示不需要GC扫描该spanClass下的对象。</p>
<p>go在编译期间，通过对代码的静态分析可以得出内存分配的类型，以及类型中是否包含指针类型。这是对象是否需要被GC扫描的重要依据。当runtime进行内存分配时，可以通过将需要扫描的和不需要扫描的对象分开管理申请和释放。提升无指针类型申请和释放的效率。</p>
<p>全局常量numSpanClasses表示了有多少个spanclass。</p>
<p>最大32KB的小内存分配器覆盖了大多数的应用场景，而这部分内存的分配，都会优先通过线程局部的分配器无锁分配，这极大加速了内存分配的性能。下面我们来看看go是如何处理小内存需求的分配的。</p>
<h2 id="小对象内存分配器"><a href="#小对象内存分配器" class="headerlink" title="小对象内存分配器"></a>小对象内存分配器</h2><h3 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h3><p>堆中的mcentral数组维护了所有67&lt;&lt;1= 134个spanClass对应的中央分配器对象，每个mcentral对象只负责一个spanClass的内存分配。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// mcentral对象数组</span></span><br><span class="line">	central [numSpanClasses]<span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="comment">// mcentral对象</span></span><br><span class="line">		mcentral mcentral</span><br><span class="line">		<span class="comment">// 用于对齐的padding块，关键词false sharing</span></span><br><span class="line">		pad      [sys.CacheLineSize - unsafe.Sizeof(mcentral&#123;&#125;)%sys.CacheLineSize]<span class="keyword">byte</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mcentral定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 互斥锁，用于保护nonempty和empty链表</span></span><br><span class="line">	lock      mutex</span><br><span class="line">	<span class="comment">// 当前mcentral对象的spanClass</span></span><br><span class="line">	spanclass spanClass</span><br><span class="line">	<span class="comment">// 依然有剩余slot的mspan链表</span></span><br><span class="line">	nonempty  mSpanList</span><br><span class="line">	<span class="comment">// 已经被mcache缓存或已无空闲空间的mspan链表。</span></span><br><span class="line">	empty     mSpanList</span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	nmalloc <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mcentral可以被理解为mcache的全局池，它分配空间以mspan为单位。nonempty链表中保存了还有可利用空间的mspans，empty中则保存了没有剩余可用空间或已经被mcache持有的mspans。这里吐槽一下这两个变量命名。</p>
<p>首先来看下mcentral缓存的增长</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">grow</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">	npages := <span class="keyword">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()])</span><br><span class="line">	size := <span class="keyword">uintptr</span>(class_to_size[c.spanclass.sizeclass()])</span><br><span class="line">	n := (npages &lt;&lt; _PageShift) / size</span><br><span class="line"></span><br><span class="line">	s := mheap_.alloc(npages, c.spanclass, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p := s.base()</span><br><span class="line">	s.limit = p + size*n</span><br><span class="line"></span><br><span class="line">	heapBitsForAddr(s.base()).initSpan(s)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">cacheSpan</span><span class="params">()</span> *<span class="title">mspan</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">uncacheSpan</span><span class="params">(s *mspan)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">freeSpan</span><span class="params">(s *mspan, preserve <span class="keyword">bool</span>, wasempty <span class="keyword">bool</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<p>grow方法获取了当前mcentral的spanClass对应需要申请的页数，以及在当前spanClass的size为单位，可以分配的对象数量n。调用mheap的alloc方法，申请一个mspan对象。并初始化mspan的结束位置limit。</p>
<p>同时，提供了三个方法用来获取和释放mspan。</p>
<h4 id="cacheSpan"><a href="#cacheSpan" class="headerlink" title="cacheSpan"></a>cacheSpan</h4><p>首先遍历nonempty链表，如果发现存在剩余空间的mspan，则返回该mspan。</p>
<p>如果nonempty链表为空，则遍历empty链表，先对链表成员mspan进行GC扫描，扫描过后如果有可用空间，则返回该mspan。</p>
<p>如果两个链表都没有可用的mspan，则调用grow方法增长mcentral。</p>
<p>通过cacheSpan获取的mspan被插入到empty链表尾部。仅有mcache对象会调用该方法。</p>
<p>mspan.incache被设置为true。</p>
<h4 id="uncacheSpan"><a href="#uncacheSpan" class="headerlink" title="uncacheSpan"></a>uncacheSpan</h4><p>如果s中还有剩余可分配空间，则将s插入到nonempty链表，否则依然在empty链表中保留。并将mspan.incache设置为false。</p>
<h4 id="freeSpan"><a href="#freeSpan" class="headerlink" title="freeSpan"></a>freeSpan</h4><p>将s移到nonempty链表。如果s中已经没有被分配的对象了（s.allocCount == 0）。则将mspan归还给mheap。调用时mspan必须没有被mcache缓存持有。</p>
<p>该方法会在mspan的sweep过程中被调用。与uncacheSpan不同，如果sweep清空了该mspan的所有slot，则mspan会从mcentral移动到mheap缓存中。</p>
<h3 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h3><p>mcache是无锁的分配器，是被m、p对象所持有的，用于加速goroutine局部小对象分配效率的局部分配器，每个p对象持有一个独立的mcache对象，当m需要被运行时，从p获得mcache指针，用于内存分配。由于一个m表达了一个系统级线程，所以mcache也可以看成是线程局部安全的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">	next_sample <span class="keyword">int32</span>   	<span class="comment">// GC相关，先不看；trigger heap sample after allocating this many bytes</span></span><br><span class="line">	local_scan  <span class="keyword">uintptr</span> 	<span class="comment">// GC相关，先不看；bytes of scannable heap allocated</span></span><br><span class="line">	</span><br><span class="line">  tiny             <span class="keyword">uintptr</span>	<span class="comment">// 当前tiny块的起始地址</span></span><br><span class="line">  tinyoffset       <span class="keyword">uintptr</span>	<span class="comment">// 当前tiny块已经分配到的位置</span></span><br><span class="line">  local_tinyallocs <span class="keyword">uintptr</span> <span class="comment">// 当前已经分配的tiny块数量</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 所有spanClass下的mspan对象，对每种spanClass保留有一个mspan用于分配。</span></span><br><span class="line">  alloc [numSpanClasses]*mspan</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 空闲栈缓存，我们会在栈一节再进行讨论</span></span><br><span class="line">  stackcache [_NumStackOrders]stackfreelist</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内存统计相关，在GC时被flush</span></span><br><span class="line">  local_largefree  <span class="keyword">uintptr</span>                  <span class="comment">// bytes freed for large objects (&gt;maxsmallsize)</span></span><br><span class="line">  local_nlargefree <span class="keyword">uintptr</span>                  <span class="comment">// number of frees for large objects (&gt;maxsmallsize)</span></span><br><span class="line">  local_nsmallfree [_NumSizeClasses]<span class="keyword">uintptr</span> <span class="comment">// number of frees for small objects (&lt;=maxsmallsize)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="mcache分配小对象空间"><a href="#mcache分配小对象空间" class="headerlink" title="mcache分配小对象空间"></a>mcache分配小对象空间</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">nextFree</span><span class="params">(spc spanClass)</span> <span class="params">(v gclinkptr, s *mspan, shouldhelpgc <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	s = c.alloc[spc]</span><br><span class="line">	shouldhelpgc = <span class="literal">false</span></span><br><span class="line">	<span class="comment">// 获取mspan中的空闲slot</span></span><br><span class="line">	freeIndex := s.nextFreeIndex()</span><br><span class="line">	<span class="keyword">if</span> freeIndex == s.nelems &#123;</span><br><span class="line">		<span class="comment">// 当前mspan已经没有可用空间</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) != s.nelems &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">"runtime: s.allocCount="</span>, s.allocCount, <span class="string">"s.nelems="</span>, s.nelems)</span><br><span class="line">			throw(<span class="string">"s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 调用refill，从mcentral申请新的mspan并填充mcache</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.refill(spc)</span><br><span class="line">		&#125;)</span><br><span class="line">    <span class="comment">// 借用当前用户goroutine辅助GC</span></span><br><span class="line">		shouldhelpgc = <span class="literal">true</span></span><br><span class="line">		s = c.alloc[spc]</span><br><span class="line"></span><br><span class="line">		freeIndex = s.nextFreeIndex()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> freeIndex &gt;= s.nelems &#123;</span><br><span class="line">		throw(<span class="string">"freeIndex is not valid"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加已申请计数，返回空闲slot起始地址</span></span><br><span class="line">	v = gclinkptr(freeIndex*s.elemsize + s.base())</span><br><span class="line">	s.allocCount++</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) &gt; s.nelems &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"s.allocCount="</span>, s.allocCount, <span class="string">"s.nelems="</span>, s.nelems)</span><br><span class="line">		throw(<span class="string">"s.allocCount &gt; s.nelems"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据spanClass获得相应的mspan对象，在其中查找空闲slot并分配。如果当前spanClass对应的mspan已经无空闲slot，则通过refill向对应spanClass的mcentral获取新的mspan。</p>
<p>虽然refill覆盖了前一个mspan在mcache中的指针，但是旧的mspan在mcentral.empty中依然存在。这部分mspan将会在GC时被扫描。</p>
<h2 id="大对象内存分配器"><a href="#大对象内存分配器" class="headerlink" title="大对象内存分配器"></a>大对象内存分配器</h2><h3 id="largeAlloc"><a href="#largeAlloc" class="headerlink" title="largeAlloc"></a>largeAlloc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largeAlloc</span><span class="params">(size <span class="keyword">uintptr</span>, needzero <span class="keyword">bool</span>, noscan <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> size+_PageSize &lt; size &#123;</span><br><span class="line">		throw(<span class="string">"out of memory"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获得满足size大小的最小page数量</span></span><br><span class="line">	npages := size &gt;&gt; _PageShift</span><br><span class="line">	<span class="keyword">if</span> size&amp;_PageMask != <span class="number">0</span> &#123;</span><br><span class="line">		npages++</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 从堆中分配空间。关键的一点是makeSpanClass传入了0。这决定了向堆分配的是整块</span></span><br><span class="line">	<span class="comment">// 的内存，而不是以spanClass划分的小内存mspan。mspan的elemsize变量会被赋值</span></span><br><span class="line">	<span class="comment">// 为pages&lt;&lt;_PageSize。</span></span><br><span class="line">	s := mheap_.alloc(npages, makeSpanClass(<span class="number">0</span>, noscan), <span class="literal">true</span>, needzero)</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"out of memory"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 初始化mspan</span></span><br><span class="line">	s.limit = s.base() + size</span><br><span class="line">  <span class="comment">// 对mspan的freeindex、allocCache、allocBits的初始化</span></span><br><span class="line">	heapBitsForAddr(s.base()).initSpan(s)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大对象通过largeAlloc分配，优先检查mheap的freelarge树堆中是否有可用空间。如果没有则向系统申请新的空间。见allocSpanLocked。</p>
<h2 id="手动管理内存的分配与释放"><a href="#手动管理内存的分配与释放" class="headerlink" title="手动管理内存的分配与释放"></a>手动管理内存的分配与释放</h2><p>手动管理的内存是指申请后mspan状态为_MSpanManual的内存，主要使用在goroutine栈内存的申请。手动管理是说它提供了一对儿allocManual/freeManual的方法，也就是说，与之前描述的分配器不同，其他分配器归还内存给堆是通过GC实现，而手动管理的内存，需要在代码中显式调用freeManual归还到堆。</p>
<h3 id="allocManual"><a href="#allocManual" class="headerlink" title="allocManual"></a>allocManual</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">allocManual</span><span class="params">(npage <span class="keyword">uintptr</span>, stat *<span class="keyword">uint64</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">	lock(&amp;h.lock)</span><br><span class="line">	s := h.allocSpanLocked(npage, stat)</span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		s.state = _MSpanManual</span><br><span class="line">		s.manualFreeList = <span class="number">0</span></span><br><span class="line">		s.allocCount = <span class="number">0</span></span><br><span class="line">		s.spanclass = <span class="number">0</span></span><br><span class="line">		s.nelems = <span class="number">0</span></span><br><span class="line">		s.elemsize = <span class="number">0</span></span><br><span class="line">		s.limit = s.base() + s.npages&lt;&lt;_PageShift</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	unlock(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="freeManual"><a href="#freeManual" class="headerlink" title="freeManual"></a>freeManual</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">freeManual</span><span class="params">(s *mspan, stat *<span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">	s.needzero = <span class="number">1</span></span><br><span class="line">	lock(&amp;h.lock)</span><br><span class="line">	*stat -= <span class="keyword">uint64</span>(s.npages &lt;&lt; _PageShift)</span><br><span class="line">	memstats.heap_sys += <span class="keyword">uint64</span>(s.npages &lt;&lt; _PageShift)</span><br><span class="line">	h.freeSpanLocked(s, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">0</span>)</span><br><span class="line">	unlock(&amp;h.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="mspan的状态变迁"><a href="#mspan的状态变迁" class="headerlink" title="mspan的状态变迁"></a>mspan的状态变迁</h2><p>前面多处涉及到了mspan的创建、归还到缓存的过程，在过程中mspan的状态一直发生着变化。go中的mspan.state字段记录了当前mspan的状态值。这里共有四种状态：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// 当mspan被创建和初始化时，状态为dead</span></span><br><span class="line">	_MSpanDead   mSpanState = <span class="literal">iota</span></span><br><span class="line">	<span class="comment">// 无论是在mcentral、mcache中缓存的mspan，还是通过largeAlloc分配的大</span></span><br><span class="line">	<span class="comment">// 内存mspan，只要是存在于mheap的busy列表中的mspan，都会被置为inuse状态</span></span><br><span class="line">	_MSpanInUse</span><br><span class="line">	<span class="comment">// Manual申请的内存，会被标记为Manual，这部分内存不会通过GC来归还，需要</span></span><br><span class="line">	<span class="comment">// 使用者显式调用freeManual归还到堆缓存</span></span><br><span class="line">	<span class="comment">// 此外allocSpanLocked中堆返回内存量大于请求量时，归还部分内存会暂时把</span></span><br><span class="line">	<span class="comment">// 两个连续mspan的状态置为Manual，避免free合并刚申请的空间。</span></span><br><span class="line">	_MSpanManual</span><br><span class="line">	<span class="comment">// 处于堆缓存free列表和mtreap的mspan会被置为free状态。</span></span><br><span class="line">	_MSpanFree</span><br><span class="line">)</span><br></pre></td></tr></table></figure>





<p><img src="https://raw.githubusercontent.com/bournex/go_source_analysis/master/images/goheap-spanstatus.jpg" alt=""></p>
<h2 id="summary-1"><a href="#summary-1" class="headerlink" title="summary"></a>summary</h2><p>在堆内存管理部分，我们首先介绍了span的概念，它是持有堆内存的最小单元。其所持有的空间大小一定是系统页的整数倍。</p>
<p>mheap结构是堆最重要的数据结构，首先我们介绍了堆缓存，以32KB划分的大小内存使用不同的数据结构维护。数据结构中的元素就是mspan对象。</p>
<p>在mheap.go中，定义了一个全局唯一的mheap对象，所以对于堆的缓存读写需要加锁。allocSpanLocked和freeSpanLocked实现了对堆缓存的申请和归还，但是其本身并没有对mheap加锁，其函数签名也表明了，对这两个方法的调用需要加锁。</p>
<p>alloc/alloc_m在对堆加锁的基础上，增加了对返回mspan的一些初始化和清零工作。</p>
<p>通过这部分学习可以得知，mspan在mheap缓存中，按照页大小管理。为了满足小内存的分配需求，这里引入了sizeclass和spanclass的概念，并在此基础上，介绍了小内存的分配方式。</p>
<p>为了加速小内存的分配，在堆提供的以page为单位的分配器之上，又提供了基于sizeclass划分mspan的mcentral全局小内存分配器和线程局部的分配器mcache。</p>
<p>对于大对象的分配，则直接从树堆中分配。</p>
<h1 id="应用级内存管理"><a href="#应用级内存管理" class="headerlink" title="应用级内存管理"></a>应用级内存管理</h1><p>以上，go中的内存分配的核心方法已经基本阐述完了。对于用户代码，我们知道局部变量是通过栈指针的移动实现空间的申请和释放，而堆内存的申请，是通过new关键字实现的，释放则是由GC实现。这一部分主要描述用户在通过new关键字创建一个堆对象后，go runtime是如何给对象分配堆空间的。</p>
<h3 id="newobject"><a href="#newobject" class="headerlink" title="newobject"></a>newobject</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newobject</span><span class="params">(typ *_type)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码的静态分析阶段，new关键字会被替换成newobject函数调用。该方法传入一个数据类型，内部仅调用了mallocgc方法。</p>
<h3 id="newarray"><a href="#newarray" class="headerlink" title="newarray"></a>newarray</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newarray</span><span class="params">(typ *_type, n <span class="keyword">int</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">0</span> || <span class="keyword">uintptr</span>(n) &gt; maxSliceCap(typ.size) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"runtime: allocation size out of range"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mallocgc(typ.size*<span class="keyword">uintptr</span>(n), typ, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果new创建的是一个数组类型，则编译器会将其替换为newarray方法调用。同样，newarray也指向了mallocgc。</p>
<p>由于go中的数组长度也是类型的一部分，所以实际在通过new创建数组对象时，并没有调用newarray，malloc.go中的newarray仅在</p>
<h3 id="mallocgc"><a href="#mallocgc" class="headerlink" title="mallocgc"></a>mallocgc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> unsafe.Pointer(&amp;zerobase)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取m对象并锁住mallocking状态.</span></span><br><span class="line">	mp := acquirem()</span><br><span class="line">	<span class="keyword">if</span> mp.mallocing != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"malloc deadlock"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> mp.gsignal == getg() &#123;</span><br><span class="line">		throw(<span class="string">"malloc during signal"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	shouldhelpgc := <span class="literal">false</span></span><br><span class="line">	dataSize := size</span><br><span class="line">	<span class="comment">// 获得m对象下的线程局部分配器mcache</span></span><br><span class="line">	c := gomcache()</span><br><span class="line">	<span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">	<span class="comment">// noscan作为spanClass的最低位，在这里获得，不需要被gc扫描的原因是当前类型中</span></span><br><span class="line">  <span class="comment">// 没有指针(kindNoPointers)</span></span><br><span class="line">	noscan := typ == <span class="literal">nil</span> || typ.kind&amp;kindNoPointers != <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> size &lt;= maxSmallSize <span class="comment">/*size &lt; 32KB*/</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize <span class="comment">/*size &lt; 16bytes*/</span> &#123;</span><br><span class="line">			<span class="comment">// tiny 对象分配</span></span><br><span class="line"></span><br><span class="line">			off := c.tinyoffset</span><br><span class="line">			<span class="comment">// 将tiny对象对齐到2的整数倍</span></span><br><span class="line">			<span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = round(off, <span class="number">8</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = round(off, <span class="number">4</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = round(off, <span class="number">2</span>)</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 优先从mcache.tiny缓存中分配tiny对象空间。</span></span><br><span class="line">			<span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">				x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">				c.tinyoffset = off + size</span><br><span class="line">				c.local_tinyallocs++</span><br><span class="line">				mp.mallocing = <span class="number">0</span></span><br><span class="line">				releasem(mp)</span><br><span class="line">				<span class="keyword">return</span> x</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 从mcahce中新申请一个tiny缓存块，找到缓存块中可用的tiny空间地址v</span></span><br><span class="line">			span := c.alloc[tinySpanClass]</span><br><span class="line">			v := nextFreeFast(span)</span><br><span class="line">			<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">				v, _, shouldhelpgc = c.nextFree(tinySpanClass)</span><br><span class="line">			&#125;</span><br><span class="line">			x = unsafe.Pointer(v)</span><br><span class="line">			(*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">			(*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">			<span class="comment">// 将剩余的tiny缓存块覆盖到mcache.tiny中，便于下一次tiny对象的分配。</span></span><br><span class="line">			<span class="keyword">if</span> size &lt; c.tinyoffset || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">				c.tiny = <span class="keyword">uintptr</span>(x)</span><br><span class="line">				c.tinyoffset = size</span><br><span class="line">			&#125;</span><br><span class="line">			size = maxTinySize</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="comment">/*size &gt;= 16bytes &amp;&amp; size &lt;= 32KB*/</span> &#123;</span><br><span class="line">      </span><br><span class="line">			<span class="comment">// 获得目标大小对应的sizeClass索引和对齐到sizeClass的size值</span></span><br><span class="line">			<span class="keyword">var</span> sizeclass <span class="keyword">uint8</span></span><br><span class="line">			<span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">				sizeclass = size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="number">-1</span>)/largeSizeDiv]</span><br><span class="line">			&#125;</span><br><span class="line">			size = <span class="keyword">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">			<span class="comment">// 构建spanClass，并从mcache对应spanClass的mspan中分配小对象空间</span></span><br><span class="line">			spc := makeSpanClass(sizeclass, noscan)</span><br><span class="line">			span := c.alloc[spc]</span><br><span class="line">			v := nextFreeFast(span)</span><br><span class="line">			<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">				v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">			&#125;</span><br><span class="line">			x = unsafe.Pointer(v)</span><br><span class="line">			<span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 清零小对象空间</span></span><br><span class="line">				memclrNoHeapPointers(unsafe.Pointer(v), size)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="comment">/*size &gt; 32KB*/</span> &#123;</span><br><span class="line">		<span class="comment">// 在系统栈上调用largeAlloc分配堆空间，将分配获得的mspan首地址作为大对象返回</span></span><br><span class="line">		<span class="comment">// 地址，相应的移动空闲块索引freeindex、allocCount</span></span><br><span class="line">		<span class="keyword">var</span> s *mspan</span><br><span class="line">		shouldhelpgc = <span class="literal">true</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			s = largeAlloc(size, needzero, noscan)</span><br><span class="line">		&#125;)</span><br><span class="line">		s.freeindex = <span class="number">1</span></span><br><span class="line">		s.allocCount = <span class="number">1</span></span><br><span class="line">		x = unsafe.Pointer(s.base())</span><br><span class="line">		size = s.elemsize</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 解锁并释放m对象</span></span><br><span class="line">	mp.mallocing = <span class="number">0</span></span><br><span class="line">	releasem(mp)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在mallocgc中可以看到，内存分配过程对tiny、small、large对象做了不同的处理。</p>
<h2 id="summary-2"><a href="#summary-2" class="headerlink" title="summary"></a>summary</h2><h1 id="内存分配流程"><a href="#内存分配流程" class="headerlink" title="内存分配流程"></a>内存分配流程</h1><h2 id="内存分配流程串联"><a href="#内存分配流程串联" class="headerlink" title="内存分配流程串联"></a>内存分配流程串联</h2><h1 id="堆内存的回收"><a href="#堆内存的回收" class="headerlink" title="堆内存的回收"></a>堆内存的回收</h1><h2 id="scavenge"><a href="#scavenge" class="headerlink" title="scavenge"></a>scavenge</h2><h2 id="scavengelist"><a href="#scavengelist" class="headerlink" title="scavengelist"></a>scavengelist</h2><h2 id="scavengetreap"><a href="#scavengetreap" class="headerlink" title="scavengetreap"></a>scavengetreap</h2><h2 id="Finalizer-amp-SetFinalizer"><a href="#Finalizer-amp-SetFinalizer" class="headerlink" title="Finalizer&amp;SetFinalizer"></a>Finalizer&amp;SetFinalizer</h2><h2 id="回收时机"><a href="#回收时机" class="headerlink" title="回收时机"></a>回收时机</h2><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="内存用量统计"><a href="#内存用量统计" class="headerlink" title="内存用量统计"></a>内存用量统计</h2><h2 id="德布鲁因序列"><a href="#德布鲁因序列" class="headerlink" title="德布鲁因序列"></a>德布鲁因序列</h2><p>德布鲁因序列描述了这样一个二进制环形串，设串的长度为2的n次方，那么串中任意连续的n个二进制bit序列，都不一样。go中应用德布鲁因序列，主要用于找出bitmask形式的64位无符号整数中，哪些位为1。为了表示一个uint64的位，这里n设为6，即64。预定义一个数组，用于表示德布鲁因子序列对应的bit位。下面的代码展示了go中德布鲁因索引的计算方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deBruijn64 = <span class="number">0x0218a392cd3d5dbf</span>	<span class="comment">//0000001000011000101000111001001011001101001111010101110110111111</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ctz64</span><span class="params">(x <span class="keyword">uint64</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	x &amp;= -x                      <span class="comment">// isolate low-order bit</span></span><br><span class="line">  y := (x * deBruijn64) &gt;&gt; <span class="number">58</span>    <span class="comment">// extract part of deBruijn sequence</span></span><br><span class="line">	i := <span class="keyword">int</span>(deBruijnIdx64[y])   <span class="comment">// convert to bit index</span></span><br><span class="line">	z := <span class="keyword">int</span>((x - <span class="number">1</span>) &gt;&gt; <span class="number">57</span> &amp; <span class="number">64</span>) <span class="comment">// adjustment if zero</span></span><br><span class="line">	<span class="keyword">return</span> i + z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>[雨痕go1.5源码分析](<a href="https://github.com/qyuhen/book/blob/master/Go" target="_blank" rel="noopener">https://github.com/qyuhen/book/blob/master/Go</a> 1.5 源码剖析.pdf)</p>
<p><a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="noopener">google tcmalloc</a></p>
<p><a href="http://supertech.csail.mit.edu/papers/debruijn.pdf" target="_blank" rel="noopener">德布鲁因算法</a></p>
<p><a href="https://zh.wikipedia.org/wiki/X86-64" target="_blank" rel="noopener">虚拟内存地址空间</a></p>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/bournex?tab=repositories" target="_blank" rel="noopener">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#综述"><span class="toc-number">1.</span> <span class="toc-text">综述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#讨论什么"><span class="toc-number">1.1.</span> <span class="toc-text">讨论什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runtime代码范围"><span class="toc-number">1.2.</span> <span class="toc-text">runtime代码范围</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#预备知识"><span class="toc-number">2.</span> <span class="toc-text">预备知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#常用全局变量"><span class="toc-number">2.1.</span> <span class="toc-text">常用全局变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计思想"><span class="toc-number">2.2.</span> <span class="toc-text">设计思想</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#系统级内存管理"><span class="toc-number">3.</span> <span class="toc-text">系统级内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原始堆内存的初始化"><span class="toc-number">3.1.</span> <span class="toc-text">原始堆内存的初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arenaHints"><span class="toc-number">3.2.</span> <span class="toc-text">arenaHints</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arena"><span class="toc-number">3.3.</span> <span class="toc-text">Arena</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arena"><span class="toc-number">3.3.1.</span> <span class="toc-text">arena</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#heapArena"><span class="toc-number">3.3.2.</span> <span class="toc-text">heapArena</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#heapArena索引计算"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">heapArena索引计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关联mspan与heapArena"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">关联mspan与heapArena</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何判定指针是否在堆上"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">如何判定指针是否在堆上</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存分配核心方法"><span class="toc-number">3.4.</span> <span class="toc-text">内存分配核心方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#系统级内存分配方法"><span class="toc-number">3.4.1.</span> <span class="toc-text">系统级内存分配方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小内存非堆分配方法"><span class="toc-number">3.4.2.</span> <span class="toc-text">小内存非堆分配方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#persistentAlloc"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">persistentAlloc</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆原始内存分配器"><span class="toc-number">3.4.3.</span> <span class="toc-text">堆原始内存分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定长对象分配器"><span class="toc-number">3.4.4.</span> <span class="toc-text">定长对象分配器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary"><span class="toc-number">3.5.</span> <span class="toc-text">summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#堆内存管理"><span class="toc-number">4.</span> <span class="toc-text">堆内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mspan"><span class="toc-number">4.1.</span> <span class="toc-text">mspan</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆缓存管理"><span class="toc-number">4.2.</span> <span class="toc-text">堆缓存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#小对象缓存"><span class="toc-number">4.2.1.</span> <span class="toc-text">小对象缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#大对象缓存"><span class="toc-number">4.2.2.</span> <span class="toc-text">大对象缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆增长"><span class="toc-number">4.3.</span> <span class="toc-text">堆增长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆内存分配与释放"><span class="toc-number">4.4.</span> <span class="toc-text">堆内存分配与释放</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#allocSpanLocked"><span class="toc-number">4.4.1.</span> <span class="toc-text">allocSpanLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#freeSpanLocked"><span class="toc-number">4.4.2.</span> <span class="toc-text">freeSpanLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#alloc-alloc-m"><span class="toc-number">4.4.3.</span> <span class="toc-text">alloc&#x2F;alloc_m</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小对象mspan"><span class="toc-number">4.5.</span> <span class="toc-text">小对象mspan</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mspan空闲块"><span class="toc-number">4.5.1.</span> <span class="toc-text">mspan空闲块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mspan空闲块的查找"><span class="toc-number">4.5.2.</span> <span class="toc-text">mspan空闲块的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#nextFreeFast"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">nextFreeFast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nextFree"><span class="toc-number">4.5.2.2.</span> <span class="toc-text">nextFree</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小对象内存划分"><span class="toc-number">4.6.</span> <span class="toc-text">小对象内存划分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeClass"><span class="toc-number">4.6.1.</span> <span class="toc-text">sizeClass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spanClass"><span class="toc-number">4.6.2.</span> <span class="toc-text">spanClass</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小对象内存分配器"><span class="toc-number">4.7.</span> <span class="toc-text">小对象内存分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mcentral"><span class="toc-number">4.7.1.</span> <span class="toc-text">mcentral</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cacheSpan"><span class="toc-number">4.7.1.1.</span> <span class="toc-text">cacheSpan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uncacheSpan"><span class="toc-number">4.7.1.2.</span> <span class="toc-text">uncacheSpan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#freeSpan"><span class="toc-number">4.7.1.3.</span> <span class="toc-text">freeSpan</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mcache"><span class="toc-number">4.7.2.</span> <span class="toc-text">mcache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mcache分配小对象空间"><span class="toc-number">4.7.2.1.</span> <span class="toc-text">mcache分配小对象空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#大对象内存分配器"><span class="toc-number">4.8.</span> <span class="toc-text">大对象内存分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#largeAlloc"><span class="toc-number">4.8.1.</span> <span class="toc-text">largeAlloc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#手动管理内存的分配与释放"><span class="toc-number">4.9.</span> <span class="toc-text">手动管理内存的分配与释放</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#allocManual"><span class="toc-number">4.9.1.</span> <span class="toc-text">allocManual</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#freeManual"><span class="toc-number">4.9.2.</span> <span class="toc-text">freeManual</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mspan的状态变迁"><span class="toc-number">4.10.</span> <span class="toc-text">mspan的状态变迁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary-1"><span class="toc-number">4.11.</span> <span class="toc-text">summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#应用级内存管理"><span class="toc-number">5.</span> <span class="toc-text">应用级内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newobject"><span class="toc-number">5.0.1.</span> <span class="toc-text">newobject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newarray"><span class="toc-number">5.0.2.</span> <span class="toc-text">newarray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mallocgc"><span class="toc-number">5.0.3.</span> <span class="toc-text">mallocgc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary-2"><span class="toc-number">5.1.</span> <span class="toc-text">summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存分配流程"><span class="toc-number">6.</span> <span class="toc-text">内存分配流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存分配流程串联"><span class="toc-number">6.1.</span> <span class="toc-text">内存分配流程串联</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#堆内存的回收"><span class="toc-number">7.</span> <span class="toc-text">堆内存的回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#scavenge"><span class="toc-number">7.1.</span> <span class="toc-text">scavenge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scavengelist"><span class="toc-number">7.2.</span> <span class="toc-text">scavengelist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scavengetreap"><span class="toc-number">7.3.</span> <span class="toc-text">scavengetreap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Finalizer-amp-SetFinalizer"><span class="toc-number">7.4.</span> <span class="toc-text">Finalizer&amp;SetFinalizer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回收时机"><span class="toc-number">7.5.</span> <span class="toc-text">回收时机</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他"><span class="toc-number">8.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存用量统计"><span class="toc-number">8.1.</span> <span class="toc-text">内存用量统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#德布鲁因序列"><span class="toc-number">8.2.</span> <span class="toc-text">德布鲁因序列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#引用"><span class="toc-number">9.</span> <span class="toc-text">引用</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&text=GO堆内存管理" target="_blank" rel="noopener"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=GO堆内存管理" target="_blank" rel="noopener"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&is_video=false&description=GO堆内存管理" target="_blank" rel="noopener"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=GO堆内存管理&body=Check out this article: http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=GO堆内存管理" target="_blank" rel="noopener"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=GO堆内存管理" target="_blank" rel="noopener"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=GO堆内存管理" target="_blank" rel="noopener"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=GO堆内存管理" target="_blank" rel="noopener"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://bournex.github.io/2020/07/03/GO%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&name=GO堆内存管理&description=" target="_blank" rel="noopener"><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 Bourne Liu
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="https://github.com/bournex?tab=repositories" target="_blank" rel="noopener">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<link rel="stylesheet" href="/lib/meslo-LG/styles.css">


<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">


<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>



    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-37473492-6', 'auto');
        ga('send', 'pageview');
    </script>



