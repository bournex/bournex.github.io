---
layout: post  
title: 理解asio异常  
date: 2016-08-04 23:25:40  
description: learning boost asio error handling.  
---
>

网络程序一大特点是错误繁多，错误码很多，很多出错现象是类似的，错误码看起来也很类似，比如在boost中错误码connection_aborted和connection_reset，细究起来还是区别蛮大的。  

最近用boost::asio封装了一个基于私有协议通信库（[SimpleTCP](https://github.com/bournex/simpletcp)），所以记录一下对异常处理的点滴分析，也有助于分析复杂的网络问题。理解这个需要有些TCP协议知识和socket编程基础。概念不清楚的可以读详解册2第18章。由于我使用了asio里的io_services异步模型，所以以下的分析会跟这个有关。  


**boost::asio::error::eof（2）**  
End of file or stream.  

> 最常见的错误。在asio中，通常会通过async_receive注册一个对socket的数据接收的异步事件到io_services。只有两种情况你注册的回调会被调用：1、收到数据，2、收到异常。eof就是由于对端调用了shutdown关闭了发送通道，当前进程收到了eof事件，意为在当前的socket上，没有再接收数据的必要了（对端已关闭，根本不会再发任何数据）。
> 需要注意的是，要认识到tcp的全双工特性，即使收到了这个消息，当前进程依然可以使用本地socket进行发送，只要本地还没有调用shutdown。虽然实际应用中，通常不会进行单边通信。


**boost::asio::error::bad_descriptor（10009）**  
Bad file descriptor.  

> 这个错误跟10053的关系很接近，区别在于发生10009错误的地方，socket已经被关闭了。对于使用者来说，就是当前进程对socket调用了close（windows是closesocket），使内核销毁了socket句柄。处于eof状态的socket，内核句柄还在，你可以使用这个socket重新调用connect重连对端。但是close过后的socket就必须要重新创建才能再次使用。所以需要做自动重连逻辑的话，就不需要对eof状态的socket调用close，可直接复用socket。

**boost::asio::error::connection_aborted（10053）**  
A connection has been aborted.  

> 很好理解，就是对本地的已经处于eof状态的socket进行写操作。

**boost::asio::error::connection_reset（10054）**  
Connection reset by peer.  

> 注意与10053有点像，但其实很容易区分。因为10053通常是在本端写eof状态的socket得到的，是主动产生的。而10054通常是在async_receive的事件通知中被动得到的。
> 这个错误的含义是，对端对established状态的socket进行了异常断开，比如直接结束进程。所以在发送逻辑中，是没有必要判断这个错误码的，因为send永远也得不到这个错误。

**boost::asio::error::not_connected（10057）**  
Transport endpoint is not connected.  

> 当调用了异步连接接口async_connect后，如果回调函数还没有返回连接结果，就在这个socket调用发送接口，发送就会失败，并收到这个错误。其含义是当前系统已经很用力的在连接了，但是还不知道成功失败。我的处理方式是，在send之前先判断连接状态，在异步连接没有收到通知连接成功之前，发送需要失败掉。

**boost::asio::error::connection_refused（10061）**  
Connection refused.  

> 对端没有在指定的端口上有监听。通常在connect失败后返回。



从TCP状态变迁上来看  
- 产生10061时，本地socket无状态，即netstat不可见。  
- 产生10057时，本地socket为SYN_SENT状态，超时后对端会发送RST，socket变为无状态。  
- 产生10054时，本地收到对端的RST，socket瞬间变为无状态。  
- 产生10053时，本端关闭，如果之后没有收到对端FIN，则进入FIN_WAIT_2状态，如果收到对端FIN，则瞬间进入TIME_WAIT状态（CLOSING状态通常很短）  
- 产生10009时，socket内核句柄已销毁，无状态。  
- 产生2时，进入CLOSE_WAIT状态，等待对方发FIN彻底关闭双工通信。  
- 以上状态我没能完全观测到。因为我在操作时，双工通信经常是同时关闭的。  


以上基本是比较容易混淆的错误码，其他的错误码都比较明确。在[SimpleTCP](https://github.com/bournex/simpletcp)中，我将2和10009映射成了同一个错误、将10053和10054映射成了同一个错误，这是因为[SimpleTCP](https://github.com/bournex/simpletcp)的使用者（需求来源）不需要知道这个区别。但是对于网络库的实现者是有必要知道的，因为在错误的地方判断错误的错误码，就像在火车站等一艘船。  
