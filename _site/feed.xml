<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bourne X</title>
    <description>A simple, beautiful theme for Jekyll that emphasizes content rather than aesthetic fluff.</description>
    <link>http://bournex.cn/</link>
    <atom:link href="http://bournex.cn/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>右值引用与move语义</title>
        <description>&lt;p&gt;写技术博客还是挺锻炼人的，因为没有深入的学习，写出来的东西就会很不堪，甚至觉得还不如课本，此前大多也是这样写着写着就坚持不下去了。
回想起当年轮子哥在博客上模仿MFC写自己的GUI库，底下评论一片吐槽其重复造轮子没必要，结果最后轮子哥造轮子造到微软西雅图总部去了。所以左思右想，即使是照本宣科，也应该坚持下去。
事实上轮子这东西，你没亲手造过根本不知道有多少坑，与其花大量时间精读别人的代码，不如理解了设计之后自己去造轮子，对于个人的成长，更有帮助。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不想亲手造轮子的程序员，不是好程序员。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;闲话至此，言归正传。&lt;/p&gt;

&lt;p&gt;早先认识到的是左值和右值的区别，简单定义为赋值符号
左侧的值为左值，而右侧的为右值，左值可以作为右值出现，但是右值不能作为左值出现。
这种定义方式在教学中足够了，但是随着C++语言的进步，出现了需要对一些特殊右值操作
的需要，这里主要指的是临时变量作为右值。在C++11标准中，对表达式做了如下的分类。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                         expression
                     	 ↙        ↘
                      glvalue     rvalue
                     ↙      ↘    ↙      ↘
                 lvalue     xvalue     prvalue
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中prvalue是pure-rvalue，比如常数、字符串常量，都属于这种纯右值，不做讨论。
而lvalue就是此前我们认识的变量标识符对象，他们可以被多次修改。而xvalue则代表生命期
很短的对象，例如在&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;char c = getchar();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;表达式中，getchar返回后
编译器会替我们构造一个看不见的char变量x，实际上c是被这个x赋值了，而当表达式结束后
x的生命期就结束了，这里的x，就属于xvalue。而glvalue表示广义的左值，理解了这些概念之后
很自然就会产生两个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;强行把xvalue作为左值有什么用呢，又不能改变它？&lt;/li&gt;
  &lt;li&gt;就算能改变它，又有什么意义呢？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这次我们定义一个复杂类型：mstr类，用于保存字符串，并为它定义拷贝构造函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class mstr
{
private:
	char *m_p;
public:
	mstr(const char *p = NULL):m_p(NULL){
		cout&amp;lt;&amp;lt;&quot;in regular constructor:&quot;&amp;lt;&amp;lt;static_cast&amp;lt;void*&amp;gt;(this)&amp;lt;&amp;lt;endl;
		if (p)
		{
			unsigned int nLen = strlen(p);
			this-&amp;gt;m_p = new char[nLen + 1];
			strcpy(this-&amp;gt;m_p, p);
			this-&amp;gt;m_p[nLen] = 0;
		}
		else
		{
			this-&amp;gt;m_p = new char[1];
			this-&amp;gt;m_p[0] = 0;
		}
	}
	~mstr()
	{
		if (this-&amp;gt;m_p)
		{
			cout&amp;lt;&amp;lt;&quot;in destructor address:&quot;&amp;lt;&amp;lt;static_cast&amp;lt;void*&amp;gt;(m_p)&amp;lt;&amp;lt;endl;
			delete []this-&amp;gt;m_p;
			this-&amp;gt;m_p = NULL;
		}
	}
	// copy
	mstr(const mstr &amp;amp; s){
		cout&amp;lt;&amp;lt;&quot;in copy constructor&quot;&amp;lt;&amp;lt;endl;
		if (!this-&amp;gt;m_p)
		{
			delete []this-&amp;gt;m_p;
			this-&amp;gt;m_p = NULL;
		}

		unsigned int nLen = strlen(s.m_p);
		this-&amp;gt;m_p = new char[nLen + 1];
		strncpy(this-&amp;gt;m_p, s.m_p, nLen);
		this-&amp;gt;m_p[nLen] = 0;
	}

	mstr &amp;amp; operator=(const mstr &amp;amp; s){
		cout&amp;lt;&amp;lt;&quot;in copy assignment&quot;&amp;lt;&amp;lt;endl;
		if (this == &amp;amp;s)
			return *this;

		delete []m_p;
		unsigned int nlen = strlen(s.m_p);
		this-&amp;gt;m_p = new char[nlen + 1];
		strcpy(this-&amp;gt;m_p, s.m_p);
		this-&amp;gt;m_p[nlen] = 0;

		return *this;
	}
public:
	void print()
	{
		cout&amp;lt;&amp;lt;&quot;address:&quot;&amp;lt;&amp;lt;static_cast&amp;lt;void*&amp;gt;(m_p)&amp;lt;&amp;lt;&quot;, value:&quot;&amp;lt;&amp;lt;m_p&amp;lt;&amp;lt;endl;
	}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;拷贝构造函数的实现方式是将源对象设置为const引用，意为不会对源对象的值进行修改，当深拷贝
发生时，假如源mstr对象保存了1MB的字符串，那么我们的左值mstr也需要new出1MB的空间保存字符串副本。
但是，如果源对象将立即被销毁（如getchar的返回值），那这次构造就产生了一次1MB的数据拷贝成本和1次delete
这也是此前C++函数返回临时对象调用深拷贝产生的效率问题。这种效率的损耗在成百上千次的调用中会被放大。&lt;/p&gt;

&lt;p&gt;定义对xvalue的引用，就是为了能让C++代码可以有机会抓住稍纵即逝的xvalue（右值引用），
并将它的值‘偷’过来（move语义），比如将xvalue的1MB字符串首地址指针直接复制过来，并在复制完成后清空源对象的指针，注意这里说的是清空，不是delete。在这个过程里由于xvalue的值发生了变化，所以不是严格意义上的右值，它具有了广义左值的属性。这就是上面两个问题的答案。&lt;/p&gt;

&lt;p&gt;了解一下这两个新特性的语法，右值引用的语法是两个’&amp;amp;’符号：
char &amp;amp;&amp;amp; c = std::move(getchar());
move语义的表现就是std库中的move函数，它的入参是一个xvalue，而返回值就是一个右值引用。
move是如此简单以至于其实现可以只有一句话：
    static_cast&amp;lt;remove_reference&amp;lt;decltype(arg)&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(arg);&lt;/p&gt;

&lt;p&gt;描述完右值引用和move语义的来龙去脉，下面改写一下此前的mstr类，实现基于右值引用和move语义的拷贝构造函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class mstr
{
private:
	char *m_p;
public:
	mstr(const char *p = nullptr):m_p(nullptr){
		cout&amp;lt;&amp;lt;&quot;in regular constructor:&quot;&amp;lt;&amp;lt;static_cast&amp;lt;void*&amp;gt;(this)&amp;lt;&amp;lt;endl;
		if (p)
		{
			unsigned int nLen = strlen(p);
			this-&amp;gt;m_p = new char[nLen + 1];
			strcpy(this-&amp;gt;m_p, p);
			this-&amp;gt;m_p[nLen] = 0;
		}
		else
		{
			this-&amp;gt;m_p = new char[1];
			this-&amp;gt;m_p[0] = 0;
		}
	}
	~mstr()
	{
		if (this-&amp;gt;m_p)
		{
			cout&amp;lt;&amp;lt;&quot;in destructor address:&quot;&amp;lt;&amp;lt;static_cast&amp;lt;void*&amp;gt;(m_p)&amp;lt;&amp;lt;endl;
			delete []this-&amp;gt;m_p;
			this-&amp;gt;m_p = nullptr;
		}
	}
	// copy
	mstr(const mstr &amp;amp; s){
		cout&amp;lt;&amp;lt;&quot;in copy constructor&quot;&amp;lt;&amp;lt;endl;
		if (!this-&amp;gt;m_p)
		{
			delete []this-&amp;gt;m_p;
			this-&amp;gt;m_p = nullptr;
		}

		unsigned int nLen = strlen(s.m_p);
		this-&amp;gt;m_p = new char[nLen + 1];
		strncpy(this-&amp;gt;m_p, s.m_p, nLen);
		this-&amp;gt;m_p[nLen] = 0;
	}

	mstr &amp;amp; operator=(const mstr &amp;amp; s){
		cout&amp;lt;&amp;lt;&quot;in copy assignment&quot;&amp;lt;&amp;lt;endl;
		if (this == &amp;amp;s)
			return *this;

		delete []m_p;
		unsigned int nlen = strlen(s.m_p);
		this-&amp;gt;m_p = new char[nlen + 1];
		strcpy(this-&amp;gt;m_p, s.m_p);
		this-&amp;gt;m_p[nlen] = 0;

		return *this;
	}

	// move
	mstr(mstr &amp;amp;&amp;amp; s){
		cout&amp;lt;&amp;lt;&quot;in move constructor&quot;&amp;lt;&amp;lt;endl;
		this-&amp;gt;m_p = s.m_p;
		s.m_p = nullptr;
	}

	mstr &amp;amp; operator=(mstr &amp;amp;&amp;amp; s){
		cout&amp;lt;&amp;lt;&quot;in move assignment&quot;&amp;lt;&amp;lt;endl;
		std::swap(m_p, s.m_p);
		return *this;
	}

public:
	void print()
	{
		cout&amp;lt;&amp;lt;&quot;address:&quot;&amp;lt;&amp;lt;static_cast&amp;lt;void*&amp;gt;(m_p)&amp;lt;&amp;lt;&quot;, value:&quot;&amp;lt;&amp;lt;m_p&amp;lt;&amp;lt;endl;
	}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实际执行效果自行验证吧。&lt;/p&gt;

&lt;p&gt;需要注意的是，std::move的参数，不能是左值，因为move拷贝构造返回后，入参的成员会被”掏空”。而左值作为变量描述符
可能在后面的代码中继续会用到，所以应避免这种用法。在实际测试当中，vs2012编译器并没有禁止将左值传入move函数，而在
xcode中则编译报错提示，rvalue reference cannot bind to lvalue。&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
        <pubDate>Wed, 11 May 2016 00:00:00 +0800</pubDate>
        <link>http://bournex.cn/c++11/2016/05/11/rvalue_reference_and_move_semantic/</link>
        <guid isPermaLink="true">http://bournex.cn/c++11/2016/05/11/rvalue_reference_and_move_semantic/</guid>
      </item>
    
      <item>
        <title>开篇</title>
        <description>&lt;p&gt;坚持写博客的缘由有千万种，不坚持写博客大多因为懒。：）&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Apr 2016 00:00:00 +0800</pubDate>
        <link>http://bournex.cn/stuff/2016/04/29/helloworld/</link>
        <guid isPermaLink="true">http://bournex.cn/stuff/2016/04/29/helloworld/</guid>
      </item>
    
  </channel>
</rss>
